#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                 ---> scafe.tool.cm.annotate <---
                     <--- tool, common mode, define and annotate tCRE --->

 Description:
   This tool defines tCRE from TSS clusters and annotates them based their overlap with gene models.

 Usage:
   scafe.tool.cm.annotate [options] --tssCluster_bed_path --tssCluster_info_path --genome --outputPrefix --outDir
   
   --tssCluster_bed_path     <required> [string]  bed file contains the ranges of filtered TSS clusters,
                                                  *.tssCluster.*.filtered.bed.gz from scafe.tool.cm.filter.pl
   --tssCluster_info_path    <required> [string]  tsv file contains the information of all TSS clusters,
                                                  *.tssCluster.log.tsv from scafe.tool.cm.filter.pl
   --genome                  <required> [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix            <required> [string]  prefix for the output files
   --outDir                  <required> [string]  directory for the output files
   --up_end5Rng              (optional) [integer] TSS clusters will be classified as gene TSS, exonic, intron 
                                                  and intergenic. $up_end5Rng determines the range upstream of 
                                                  annotated gene TSS to be used for gene TSS assignment 
                                                  (default = 500)
   --dn_end5Rng              (optional) [integer] TSS clusters will be classified as gene TSS, exonic, intron 
                                                  and intergenic. $dn_end5Rng determines the range downstream of 
                                                  annotated gene TSS to be used for gene TSS assignment 
                                                  (default = 500)
   --exon_slop_rng           (optional) [integer] TSS clusters will be classified as gene TSS, exonic, intron 
                                                  and intergenic. $exon_slop_rng determines the range to be extended
                                                  (i.e. slopped) from exon for assignment of exonic class. 
                                                  Used -1 to NOT to extend (default = -1)
   --merge_dist              (optional) [integer] TSS clusters outside annotated gene promoters are grouped
                                                  as "dummy genes" (for operational uniformity) by merging closely 
                                                  located TSS clusters.  $merge_dist determines the maximum distances 
                                                  between TSS clusters to be merged (default = 500)
   --addon_length            (optional) [integer] see $merge_dist. add-on "dummy transcrips" will assigned to TSS cluster of 
                                                  "dummy genes" (for operational uniformity).$addon_length determines 
                                                  the length of these add-on "dummy transcrips" (default = 500).
   --proximity_slop_rng      (optional) [integer] TSS clusters will be assigned to annotated gene TSS are "proximal"
                                                  TSS clusters. $proximity_slop_rng determines the range to be extended
                                                  (i.e. slopped) from gene TSS for assignment of proximal TSS clusters. 
                                                  (default = 500)
   --merge_strandness        (optional) [string]  see $merge_dist. $merge_strandness decides the merge to be 
                                                  strand-aware ("stranded") or strand-agnostic "strandless".
                                                  (default = strandless)
   --proximal_strandness     (optional) [string]  closely located proximal TSS clusters are merged  
                                                  tCREs. $proximal_strandness decides the merge to be 
                                                  strand-aware ("stranded") or strand-agnostic "strandless".
                                                  (default = stranded)
   --CRE_extend_size         (optional) [integer] tCREs were defined by merging the extended ranges of TSS clusters.
                                                  $CRE_extend_size determine the size of this range (both sides of 
                                                  summit) (default = 500)
   --CRE_extend_upstrm_ratio (optional) [float]   see $CRE_extend_size. $CRE_extend_upstrm_ratio determines the ratio 
                                                  (X:1) of flanking sizes on the upstream and downstream of summit. 
                                                  e.g. $CRE_extend_upstrm_ratio=4, upstream and downstream size will be 
                                                  taken as 4:1 ratio. $CRE_extend_size=500 and $CRE_extend_upstrm_ratio=4,
                                                  upstream and downstream will be 400 and 100 respectively 
                                                  (default = 4)
   --overwrite               (optional) [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.annotate \
   --overwrite=yes \
   --tssCluster_bed_path=./demo/output/sc.solo/filter/demo/bed/demo.tssCluster.default.filtered.bed.gz \
   --tssCluster_info_path=./demo/output/sc.solo/filter/demo/log/demo.tssCluster.log.tsv \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/annotate/

=head1 VERSION

1.0

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->2655
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->573
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $outputPrefix, $outDir, $overwrite) = &readParameters();#->2188
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $mask_class_hsh_ref = {
	'Mt_rRNA' => 1,
	'Mt_tRNA' => 1,
	'rRNA' => 1,
	'snRNA' => 1,
	'snoRNA' => 1,
	'structural_RNA' => 1,
	'small_RNA' => 1,
	'miRNA' => 1,
};
my $paramTag = "$outputPrefix";
#$chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path,
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_gtf_dir = "$result_dir/gtf/"; push @mkDirAry, $result_gtf_dir;
my $tmp_bed_dir = "$result_dir/bed/tmp/"; push @mkDirAry, $tmp_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->1024
&printStartOrFinishMessage("startMessage");#->1330
my ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
my ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path) = &checkTranscriptInfoBedChromSizeGeneInfoPath($genome);#->544
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_readInfo
#
#<section ID="readInfo" num="3">
my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);#->1966
my ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path) = &readTranscriptBed($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir);#->2253
my ($geneInfoHsh_ref) = &readTranscriptInfo($transcript_info_path, $trnscptInfoHsh_ref);#->2332
&readGeneInfo($gene_info_path, $geneInfoHsh_ref);#->2116
my ($coding_class_hsh_ref) = &defineCodingClasses();#->665
my ($end5_rng_bed_path, $end5_point_bed_path) = &printEnd5Bed($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir);#->1129
my ($clusterInfoHsh_ref) = &readClusterBed($tssCluster_bed_path);#->1991
&readClusterInfo($tssCluster_info_path, $clusterInfoHsh_ref);#->2055
my ($extended_tssCluster_bed_path) = &generateExtendedCluster($clusterInfoHsh_ref, $result_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio);#->842
&intersectCluster($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);#->963
&filterUnannotatedCluster($clusterInfoHsh_ref);#->763
my ($superClusterHsh_ref) = &getSuperCluster($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin);#->908
&addonTranscript($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref);#->308
&summerizeGeneInfo($geneInfoHsh_ref, $trnscptInfoHsh_ref);#->2597
&addGeneMask($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref);#->273
&assignClusterProximity($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);#->405
&rankCAGEClusterWithinGene($clusterInfoHsh_ref, $geneInfoHsh_ref);#->1850
my ($CREInfoHsh_ref) = &defineCRE($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path);#->591
&summerizeCREInfo($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref);#->2527
&rankCREWithinGene($CREInfoHsh_ref, $geneInfoHsh_ref);#->1908
&removeUnsupportedGene($geneInfoHsh_ref, $trnscptInfoHsh_ref);#->2413
&printAllBed($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix);#->1049
&printTableClusterInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1496
&printTableGeneInfo($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1611
&printTableIDMappingInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1673
&printTableTranscriptInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1733
&printTableCREInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1364
&printTrnscptGtf($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix);#->1790
&removeTmpBedDir($tmp_bed_dir);#->2394
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->1210
&printStartOrFinishMessage("finishMessage");#->1330
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	checkTools [n=1]:
#		checkBedtoolsVersion
#
#	general [n=6]:
#		checkBedtoolsVersion, currentTime, logCalledCMDAndScript
#		printStartOrFinishMessage, readParameters, timeStamp
#
#	getTextInfo [n=1]:
#		readGeneInfo
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	specific [n=1]:
#		printTrnscptGtf
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=31]:
#		addGeneMask, addonTranscript, assignClusterProximity
#		checkTranscriptInfoBedChromSizeGeneInfoPath, defineCRE, defineCodingClasses
#		exonRngToGtf, filterUnannotatedCluster, generateAddonGene
#		generateExtendedCluster, getSuperCluster, intersectCluster
#		printAllBed, printEnd5Bed, printTableCREInfo
#		printTableClusterInfo, printTableGeneInfo, printTableIDMappingInfo
#		printTableTranscriptInfo, rankCAGEClusterWithinGene, rankCREWithinGene
#		readChromSize, readClusterBed, readClusterInfo
#		readTranscriptBed, readTranscriptInfo, removeTmpBedDir
#		removeUnsupportedGene, storeCREInfoFromBed, summerizeCREInfo
#		summerizeGeneInfo
#
#====================================================================================================================================================#

sub addGeneMask {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $geneInfoHsh_ref, $mask_class_hsh_ref, $trnscptInfoHsh_ref
#	output: 
#	toCall: &addGeneMask($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref);
#	calledInLine: 201
#....................................................................................................................................................#
	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref) = @_;
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $mask = 'no';
		$mask = 'yes' if exists $mask_class_hsh_ref->{$geneClass};
		$geneInfoHsh_ref->{$geneID}{'mask'} = $mask;
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			#die "$trnscptID\n" if not exists $trnscptInfoHsh_ref->{$trnscptID}{'bedLine'};
			$trnscptInfoHsh_ref->{$trnscptID}{'mask'} = $mask;
		}
	}
	
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		my $mask = 'yes';
		foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'geneID'}}) {
			$mask = 'no' if $geneInfoHsh_ref->{$geneID}{'mask'} eq 'no';
		}
		$clusterInfoHsh_ref->{$clusterID}{'mask'} = $mask;
	}
	
	return ();
}
sub addonTranscript {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: generateAddonGene|794, reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $addon_length, $chrom_size_hsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref, $superClusterHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &addonTranscript($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref);
#	calledInLine: 199
#....................................................................................................................................................#
	
	my ($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref) = @_;

	my $trnscptIDHsh_ref = {};

	&reportAndLogStatus("creating addon transcripts", 10, "\n");#->2455
	foreach my $superclusterID (keys %{$superClusterHsh_ref}) {
		
		my ($geneID, $addon_chrom) = &generateAddonGene($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID);#->794

		$geneInfoHsh_ref->{$geneID}{'geneName'} = $geneID;
		$geneInfoHsh_ref->{$geneID}{'geneClass'} = 'unanno_tss';
		
		foreach my $clusterID (@{$superClusterHsh_ref->{$superclusterID}}) {

			my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
			my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
			
			my $start = $clusterInfoHsh_ref->{$clusterID}{'start'};
			my $end = $clusterInfoHsh_ref->{$clusterID}{'end'};
			my $peakPos = $clusterInfoHsh_ref->{$clusterID}{'peakPos'};
			my @t_strandAry = ();

			if ($strand eq '.') {
				push @t_strandAry, '+';
				push @t_strandAry, '-';
			} else {
				push @t_strandAry, $strand;
			}

			foreach my $t_strand (@t_strandAry) {
				my $t_start;
				my $t_end;
				my $addon_t_strand;
				
				if ($t_strand eq '+') {
					$t_start = $peakPos;
					$t_end = $t_start + $addon_length;
					$addon_t_strand = 'F';
				} else {
					$t_start = $peakPos - $addon_length;
					$t_end = $peakPos;
					$addon_t_strand = 'R';
				}
				
				$t_start = 1 if $t_start < 1;
				$t_end = $chrom_size_hsh_ref->{$chrom}-1 if $t_end >= $chrom_size_hsh_ref->{$chrom};
				
				my $addon_t_start = sprintf "%.9d", $t_start;

				my $trnscptID = "ADDT".$addon_chrom.$addon_t_start.'.'.$addon_t_strand;

				if (exists $trnscptInfoHsh_ref->{$trnscptID}) {
					$trnscptIDHsh_ref->{$trnscptID}++;
					$trnscptID = "ADDT".$addon_chrom.$addon_t_start.'.'.$addon_t_strand.$trnscptIDHsh_ref->{$trnscptID};
				}
				
				$trnscptIDHsh_ref->{$trnscptID}++;
				$trnscptInfoHsh_ref->{$trnscptID}{'chrom'} = $chrom;
				$trnscptInfoHsh_ref->{$trnscptID}{'strand'} = $t_strand;
				@{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}} = ($t_start, $t_end);

				$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID} = 'addon';
				$clusterInfoHsh_ref->{$clusterID}{'geneID'}{$geneID}++;

				$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} = 'addon';
				$trnscptInfoHsh_ref->{$trnscptID}{'geneID'} = $geneID;

				$geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} = 'addon';
				$geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID}++;

				my $chromStart = $t_start - 1;
				my $chromEnd = $t_end;
				my $thickStart = $chromStart;
				my $thickEnd = $chromEnd;
				my $blockSizes = $chromEnd - $chromStart;
				my $blockCount = 1;
				my $blockStarts = 0;
	
				$trnscptInfoHsh_ref->{$trnscptID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $trnscptID, '0', $t_strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];

			}
		}
	}	
}
sub assignClusterProximity {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $end5_point_bed_path, $geneInfoHsh_ref, $proximity_slop_rng, $transcript_in_scope_bed_path, $trnscptInfoHsh_ref, $tssCluster_bed_path
#	output: none
#	toCall: &assignClusterProximity($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);
#	calledInLine: 202
#....................................................................................................................................................#
	
	my ($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin) = @_;

	&reportAndLogStatus("assigning region to cluster", 10, "\n");#->2455
	
	my $region_cmd_hsh_ref = {
		'end5' => {
			'in_bed6_cmd' => "cut -f 1-6 $end5_point_bed_path",
			'slop_rng' => $proximity_slop_rng,
		},
		'exon' => {
			'in_bed6_cmd' => "$bedtools_bin bed12tobed6 -i $transcript_in_scope_bed_path",
			'slop_rng' => 0,
		},
		'intron' => {
			'in_bed6_cmd' => "cut -f 1-6 $transcript_in_scope_bed_path",
			'slop_rng' => 0,
		},
	};
	
	foreach my $regionType (qw/end5 exon intron/) {
		foreach my $oritentation (qw/ss as/) {
		
			&reportAndLogStatus("Getting cluster at $regionType $oritentation", 10, "\n");#->2455

			my $in_bed6_cmd = $region_cmd_hsh_ref->{$regionType}{'in_bed6_cmd'};
			my $slop_rng = $region_cmd_hsh_ref->{$regionType}{'slop_rng'};
			
			open BEDTOOLS, "$in_bed6_cmd | $bedtools_bin slop -b $slop_rng -i stdin -g $chrom_size_path | $bedtools_bin intersect -wo -a stdin -b $tssCluster_bed_path |" ;

			while (<BEDTOOLS>) {
				#chr10	13141663	13142302	ENST00000482140.5_1	1	+	chr10	13142075	13142193	p1@OPTN	247174	+	13142162	13142163	255,0,0	118
				my (@splt) = split /\t/;
				my $clusterID = $splt[9];
				next if exists $clusterInfoHsh_ref->{$clusterID}{'regionType'};

				my $cluster_strand = $splt[11];
				my $trnscpt_strand = $splt[5];
				my $trnscptID = $splt[3];
				
				my $oritentation_matched = 'no';
				my $assigned_orientation;

				if ($cluster_strand eq '.') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'ns';
					
				} elsif ($cluster_strand eq $trnscpt_strand and $oritentation eq 'ss') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'ss';
					
				
				} elsif ($cluster_strand ne $trnscpt_strand and $oritentation eq 'as') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'as';
				}
				
				if ($oritentation_matched eq 'yes') {

					die "$trnscptID does not exists in trnscptInfoHsh_ref\n" if not exists $trnscptInfoHsh_ref->{$trnscptID};
					die "$clusterID does not exists in clusterInfoHsh_ref\n" if not exists $clusterInfoHsh_ref->{$clusterID};

					my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
					
					$clusterInfoHsh_ref->{$clusterID}{'regionGeneID'} = $geneID;
					$clusterInfoHsh_ref->{$clusterID}{'regionType'} = $regionType;
					$clusterInfoHsh_ref->{$clusterID}{'regionOritentation'} = $oritentation;
				}
			}
			close BEDTOOLS;
		}
	}
	
	&reportAndLogStatus("Adding intergenic region type", 10, "\n");#->2455
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'regionType'}) {
			$clusterInfoHsh_ref->{$clusterID}{'regionGeneID'} = '__na';
			$clusterInfoHsh_ref->{$clusterID}{'regionType'} = 'intergenic';
			$clusterInfoHsh_ref->{$clusterID}{'regionOritentation'} = 'ns';
		}
	}

	&reportAndLogStatus("Adding proximity", 10, "\n");#->2455
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if ($clusterInfoHsh_ref->{$clusterID}{'regionType'} eq 'end5') {
			$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'proximal';

		#} elsif ($clusterInfoHsh_ref->{$clusterID}{'regionType'} eq 'exon') {
			#$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'exonic';
		
		} else {
			$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'distal';
		}
	}

}
sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1254
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|129
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin
#	toCall: my ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 144
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->1254
	
	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1254
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1254
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->1254
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->1254
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->1254
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->1254
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub checkTranscriptInfoBedChromSizeGeneInfoPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|162
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path
#	toCall: my ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path) = &checkTranscriptInfoBedChromSizeGeneInfoPath($genome);
#	calledInLine: 179
#....................................................................................................................................................#
	my ($genome) = @_;

	#$chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path,

	my $dirPath = dirname(rel2abs($0));
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	my $gene_info_path = "$dirPath/../resources/genome/$genome/tsv/gene.info.tsv";
	my $transcript_info_path = "$dirPath/../resources/genome/$genome/tsv/transcript.info.tsv";
	my $transcript_bed_path = "$dirPath/../resources/genome/$genome/bed/transcript.bed.gz";

	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	die "genome $genome does not have gene_info_path. Please rerun prep_genome step\n" if not -s $gene_info_path;
	die "genome $genome does not have transcript_info_path. Please rerun prep_genome step\n" if not -s $transcript_info_path;
	die "genome $genome does not have transcript_bed_path. Please rerun prep_genome step\n" if not -s $transcript_bed_path;

	return ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1330, reportAndLogStatus|2455
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|162, 4_finishingTasks|220
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 124, 1346, 1350, 1355, 1359, 2471, 2472
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineCRE {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455, storeCREInfoFromBed|2477
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CRE_extend_size, $CRE_extend_upstrm_ratio, $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $extended_tssCluster_bed_path, $proximal_strandness, $tmp_bed_dir
#	output: $CREInfoHsh_ref
#	toCall: my ($CREInfoHsh_ref) = &defineCRE($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path);
#	calledInLine: 204
#....................................................................................................................................................#
	my ($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path) = @_;
	
	my $CREInfoHsh_ref = {};

	{	
		&reportAndLogStatus("defining proximal CRE", 10, "\n");#->2455
		my $proximity = 'proximal';
		my $strand_opt = '-s';
		$strand_opt = '' if $proximal_strandness eq 'strandless';
	
		my $tmp_merged_CRE_bed = "$tmp_bed_dir/cluster_merged_CRE.$proximity.bed";
		my $tmp_indiv_CRE_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.bed";
		my $tmp_indiv_CRE_plus_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.plus_edge_distal.bed";
	
		open INDIVCRE, "| sort -k1,1 -k2,2n >$tmp_indiv_CRE_bed";
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			if ($clusterInfoHsh_ref->{$clusterID}{'proximity'} eq $proximity) {
				my $extendedStart = $clusterInfoHsh_ref->{$clusterID}{'extendedStart'};
				my $extendedEnd = $clusterInfoHsh_ref->{$clusterID}{'extendedEnd'};
				my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
				my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
				my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
				print INDIVCRE join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand)), "\n";
			}
		}
		close INDIVCRE;
		
		#---[2021/01/13 1:13] get the distal clusters at the edge of the proximal clusters
		system  "$bedtools_bin intersect $strand_opt -wa -a $extended_tssCluster_bed_path -b $tmp_indiv_CRE_bed >$tmp_indiv_CRE_plus_bed";

		system  "$bedtools_bin merge $strand_opt -c 4,5,6 -o distinct,sum,distinct -delim \";\" -i $tmp_indiv_CRE_plus_bed >$tmp_merged_CRE_bed";
		&storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);#->2477
	}

	{
		&reportAndLogStatus("defining distal CRE", 10, "\n");#->2455
		my $proximity = 'distal';
		my $strand_opt = '';
	
		my $tmp_merged_CRE_bed = "$tmp_bed_dir/cluster_merged_CRE.$proximity.bed";
		my $tmp_indiv_CRE_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.bed";
	
		open INDIVCRE, "| sort -k1,1 -k2,2n >$tmp_indiv_CRE_bed";
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			#---[2021/01/13 1:21] get the unassigned CREID
			if (not exists $clusterInfoHsh_ref->{$clusterID}{'CREID'}) {
				my $extendedStart = $clusterInfoHsh_ref->{$clusterID}{'extendedStart'};
				my $extendedEnd = $clusterInfoHsh_ref->{$clusterID}{'extendedEnd'};
				my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
				my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
				my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
				print INDIVCRE join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand)), "\n";
			}
		}
		close INDIVCRE;
		
		system  "$bedtools_bin merge $strand_opt -c 4,5,6 -o distinct,sum,distinct -delim \";\" -i $tmp_indiv_CRE_bed >$tmp_merged_CRE_bed";
		&storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);#->2477
	}

	return ($CREInfoHsh_ref);
}
sub defineCodingClasses {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: none
#	output: $coding_class_hsh_ref
#	toCall: my ($coding_class_hsh_ref) = &defineCodingClasses();
#	calledInLine: 191
#....................................................................................................................................................#
	
	my $coding_class_hsh_ref = {
		"antisense" => "noncoding",
		"IG_C_gene" => "coding",
		"IG_C_pseudogene" => "pseudogene",
		"IG_D_gene" => "coding",
		"IG_J_gene" => "coding",
		"IG_J_pseudogene" => "pseudogene",
		"IG_pseudogene" => "pseudogene",
		"IG_V_gene" => "coding",
		"IG_V_pseudogene" => "pseudogene",
		"lincRNA" => "noncoding",
		"lncRNA" => "noncoding",
		"miRNA" => "others",
		"misc_RNA" => "others",
		"Mt_rRNA" => "others",
		"Mt_tRNA" => "others",
		"polymorphic_pseudogene" => "pseudogene",
		"processed_pseudogene" => "pseudogene",
		"processed_transcript" => "others",
		"protein_coding" => "coding",
		"pseudogene" => "pseudogene",
		"rRNA" => "others",
		"rRNA_pseudogene" => "others",
		"scRNA" => "others",
		"sense_intronic" => "noncoding",
		"sense_overlapping" => "noncoding",
		"snoRNA" => "others",
		"snRNA" => "others",
		"TEC" => "noncoding",
		"transcribed_processed_pseudogene" => "pseudogene",
		"transcribed_unitary_pseudogene" => "pseudogene",
		"transcribed_unprocessed_pseudogene" => "pseudogene",
		"translated_processed_pseudogene" => "pseudogene",
		"translated_unprocessed_pseudogene" => "pseudogene",
		"TR_C_gene" => "coding",
		"TR_D_gene" => "coding",
		"TR_J_gene" => "coding",
		"TR_J_pseudogene" => "pseudogene",
		"TR_V_gene" => "coding",
		"TR_V_pseudogene" => "pseudogene",
		"unitary_pseudogene" => "pseudogene",
		"unprocessed_pseudogene" => "pseudogene",
		"vaultRNA" => "others",
		
		"coding_mRNA" => "coding",
		"lncRNA_antisense" => "noncoding",
		"lncRNA_divergent" => "noncoding",
		"lncRNA_intergenic" => "noncoding",
		"lncRNA_sense_intronic" => "noncoding",
		"pseudogene" => "pseudogene",
		"sense_overlap_RNA" => "noncoding",
		"short_ncRNA" => "noncoding",
		"small_RNA" => "others",
		"structural_RNA" => "others",
		"uncertain_coding" => "others",

		#"unanno_tss" => "others",
	};

	return ($coding_class_hsh_ref);
}
sub exonRngToGtf {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: printTrnscptGtf|1790
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|184
#	input: $chrom, $exonRngAry_ref, $geneID, $sourceTag, $strand, $trnscptID
#	output: $gtf_ary_ref
#	toCall: my ($gtf_ary_ref) = &exonRngToGtf($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag);
#	calledInLine: 1835
#....................................................................................................................................................#
	my ($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag) = @_;
	
	my $gtf_ary_ref = [];
	
	my @rngAry = sort {$a <=> $b} @{$exonRngAry_ref};
	for (my $i=0; $i < $#rngAry; $i += 2) {
		my ($exonStart, $exonEnd) = ($rngAry[$i], $rngAry[$i+1]);
		push @{$gtf_ary_ref}, [$chrom, $sourceTag, 'exon', $exonStart, $exonEnd, '.', $strand, '.', "gene_id \"$geneID\"; transcript_id \"$trnscptID\";"];
	}
	
	return ($gtf_ary_ref);
}
sub filterUnannotatedCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref
#	output: 
#	toCall: &filterUnannotatedCluster($clusterInfoHsh_ref);
#	calledInLine: 197
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref) = @_;
	
	&reportAndLogStatus("removing unanno cluster within filter region", 10, "\n");#->2455
	my $num_rm = 0;
	my $num_unanno = 0;
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}) {
			$num_unanno++;
			if ($clusterInfoHsh_ref->{$clusterID}{'filter'} eq 'yes') {
				delete $clusterInfoHsh_ref->{$clusterID};
				$num_rm++;
			}
		}
	}

	&reportAndLogStatus("$num_rm of $num_unanno unannotated clusters filtered out.", 10, "\n");#->2455
	
	return ();
}
sub generateAddonGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: addonTranscript|308
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|184
#	input: $clusterInfoHsh_ref, $superClusterHsh_ref, $superclusterID
#	output: $addon_chrom, $geneID
#	toCall: my ($geneID, $addon_chrom) = &generateAddonGene($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID);
#	calledInLine: 327
#....................................................................................................................................................#
	
	my ($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID) = @_;
	
	my $chrom;
	my $g_start = 0;
	my $strand_hsh_ref = {};
	
	foreach my $clusterID (@{$superClusterHsh_ref->{$superclusterID}}) {
		$chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
		$g_start = $clusterInfoHsh_ref->{$clusterID}{'start'} if $g_start < $clusterInfoHsh_ref->{$clusterID}{'start'};
		my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
		$strand_hsh_ref->{$strand}++;
	}
	my $addon_g_strand;
	
	if ((exists $strand_hsh_ref->{'+'} and exists $strand_hsh_ref->{'-'}) or (exists $strand_hsh_ref->{'.'})) {
		$addon_g_strand = 'B';

	} elsif (exists $strand_hsh_ref->{'-'} and not exists $strand_hsh_ref->{'+'}) {
		$addon_g_strand = 'R';
		
	} elsif (exists $strand_hsh_ref->{'+'} and not exists $strand_hsh_ref->{'-'}) {
		$addon_g_strand = 'F';

	} else {
		die "strand conflicts\n";
	}
	
	my $addon_chrom = $chrom;
	$addon_chrom =~ s/^chr//;
	$addon_chrom = '0'.$addon_chrom if length($addon_chrom) == 1;
	my $addon_g_start = sprintf "%.9d", $g_start;
	my $geneID = "ADDG".$addon_chrom.$addon_g_start.'.'.$addon_g_strand;
	
	return ($geneID, $addon_chrom);
}
sub generateExtendedCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $result_bed_dir
#	output: $extended_tssCluster_bed_path
#	toCall: my ($extended_tssCluster_bed_path) = &generateExtendedCluster($clusterInfoHsh_ref, $result_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio);
#	calledInLine: 195
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $result_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio) = @_;
	
	my $extended_tssCluster_bed_path = "$result_bed_dir/extended_cluster.bed";
	&reportAndLogStatus("generating extended cluster", 10, "\n");#->2455
	open (EXTENDBED, "| sort -k1,1 -k2,2n >$extended_tssCluster_bed_path");
	
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
	
		my ($chrom, $cluster_chromStart, $cluster_chromEnd, undef, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = @{$clusterInfoHsh_ref->{$clusterID}{'bedLine'}};
		my $extendedStart;
		my $extendedEnd;
		
		if ($CRE_extend_size > 0 and $CRE_extend_upstrm_ratio > 0) {
			my $left_ratio;
			my $right_ratio;

			if ($strand eq '+') {
				$left_ratio = $CRE_extend_upstrm_ratio;
				$right_ratio = 1;

			} elsif ($strand eq '-') {
				$left_ratio = 1;
				$right_ratio = $CRE_extend_upstrm_ratio;

			} else {
				$left_ratio = 1;
				$right_ratio = 1;
			}
		
			my $left_size = int($CRE_extend_size*($left_ratio/($left_ratio+$right_ratio)));
			my $right_size = int($CRE_extend_size*($right_ratio/($left_ratio+$right_ratio)));
		
			my $peakPos = $thickEnd;
			$extendedStart = $peakPos - $left_size - 1;
			$extendedEnd = $peakPos + $right_size;
		
			$extendedStart = 0 if $extendedStart < 0;

		} else {

			$extendedStart = $cluster_chromStart;
			$extendedEnd = $cluster_chromEnd;
		}
		
		$clusterInfoHsh_ref->{$clusterID}{'extendedStart'} = $extendedStart;
		$clusterInfoHsh_ref->{$clusterID}{'extendedEnd'} = $extendedEnd;
		
		print EXTENDBED join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		
	}
	close EXTENDBED;
	
	return ($extended_tssCluster_bed_path);
}
sub getSuperCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $tmp_bed_dir
#	output: $superClusterHsh_ref
#	toCall: my ($superClusterHsh_ref) = &getSuperCluster($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin);
#	calledInLine: 198
#....................................................................................................................................................#
	
	my ($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin) = @_;
	
	my $superClusterHsh_ref = {};
	
	my $unanno_tssCluster_bed_path = "$tmp_bed_dir/unanno_cluster.bed";
	&reportAndLogStatus("getting unanno supercluster", 10, "\n");#->2455
	open (UNANNOBED, "| sort -k1,1 -k2,2n >$unanno_tssCluster_bed_path");
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}) {
			my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
			my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
			my $start = $clusterInfoHsh_ref->{$clusterID}{'start'};
			my $end = $clusterInfoHsh_ref->{$clusterID}{'end'};
			print UNANNOBED join "", (join "\t", ($chrom, $start, $end, $clusterID, '1', $strand)), "\n";
		}
	}
	close UNANNOBED;
	
	if ($merge_strandness eq 'stranded') {
		open (SUPERCLUSTER, "$bedtools_bin cluster -s -d $merge_dist -i $unanno_tssCluster_bed_path |");
	} elsif ($merge_strandness eq 'strandless') {
		open (SUPERCLUSTER, "$bedtools_bin cluster -d $merge_dist -i $unanno_tssCluster_bed_path |");
	} else {
		die "merge_strandness $merge_strandness is not valid\n";
	}

	while (<SUPERCLUSTER>) {
		chomp;
		my @splt = split /\t/;
		my $clusterID = $splt[3];
		my $superclusterID = $splt[-1];
		push @{$superClusterHsh_ref->{$superclusterID}}, $clusterID;
	}	
	close SUPERCLUSTER;
	
	my $num_superclusters = keys %{$superClusterHsh_ref};
	&reportAndLogStatus("$num_superclusters super clusters defined", 10, "\n");#->2455
	
	die "supercluster definition problem\n" if $num_superclusters == 0;
	
	return ($superClusterHsh_ref);
}
sub intersectCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $end5_rng_bed_path, $exon_slop_rng, $geneInfoHsh_ref, $transcript_in_scope_bed_path, $trnscptInfoHsh_ref, $tssCluster_bed_path
#	output: none
#	toCall: &intersectCluster($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);
#	calledInLine: 196
#....................................................................................................................................................#
	
	my ($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin) = @_;
	
	foreach my $end5_exon (qw/end5 exon/) {
		
		&reportAndLogStatus("Intersecting cluster and transcript $end5_exon", 10, "\n");#->2455
		
		if ($end5_exon eq 'end5') {
			open BEDTOOLS, "$bedtools_bin intersect -wo -a $end5_rng_bed_path -b $tssCluster_bed_path |" ;
		} elsif ($end5_exon eq 'exon') {
			
			#---[4/18/17 12:13] skip if exon_slop_rng == 1
			if ($exon_slop_rng == -1) {
				&reportAndLogStatus("exon_slop_rng==-1. Skipping exon intersect.", 10, "\n");#->2455
				next;
			}
			
			open BEDTOOLS, "$bedtools_bin bed12tobed6 -i $transcript_in_scope_bed_path | $bedtools_bin slop -b $exon_slop_rng -i stdin -g $chrom_size_path | $bedtools_bin intersect -s -wo -a stdin -b $tssCluster_bed_path |" ;
		}

		while (<BEDTOOLS>) {
			#chr10	13141663	13142302	ENST00000482140.5_1	1	+	chr10	13142075	13142193	p1@OPTN	247174	+	13142162	13142163	255,0,0	118
			my (@splt) = split /\t/;
			my $clusterID = $splt[9];
			my $cluster_strand = $splt[11];
			my $trnscptIDStr = $splt[3];
			my $trnscpt_strand = $splt[5];
			my @trnscptIDStrAry = split /\|/, $trnscptIDStr;
			my $trnscptID = $trnscptIDStrAry[-1];
			
			if ($cluster_strand eq '.' or $cluster_strand eq $trnscpt_strand) {
				#---[4/16/17 0:01] skip end5
				next if exists $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID};

				die "$trnscptID does not exists in trnscptInfoHsh_ref\n" if not exists $trnscptInfoHsh_ref->{$trnscptID};
				die "$clusterID does not exists in clusterInfoHsh_ref\n" if not exists $clusterInfoHsh_ref->{$clusterID};
				my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
		
				$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} = $end5_exon;
				$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID} = $end5_exon;
				$clusterInfoHsh_ref->{$clusterID}{'geneID'}{$geneID} = $end5_exon;
				$geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} = $end5_exon;

				$clusterInfoHsh_ref->{$clusterID}{'type'} = 'gene_tss';
			}
		}
		close BEDTOOLS;
	}
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|162
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 176
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printAllBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_bed_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printAllBed($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix);
#	calledInLine: 208
#....................................................................................................................................................#

	my ($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix) = @_;
	
	my %itemHsh = (
		'gene' => $geneInfoHsh_ref,
		'transcript' => $trnscptInfoHsh_ref,
		'cluster' => $clusterInfoHsh_ref,
		'CRE' => $CREInfoHsh_ref,
	);

	my $strand_color_hsh_ref = {
		'+' => '228,26,28',
		'-' => '55,126,184',
		'.' => '77,175,74',
	};
	
	foreach my $item_type (keys %itemHsh) {
		&reportAndLogStatus("printing $item_type bed", 10, "\n");#->2455
		my $hsh_ref = $itemHsh{$item_type};
		my $filePath;
		
		$filePath = "$result_bed_dir/$outputPrefix.$item_type.coord.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all $item_type, with $item_type ID at 4th column";

		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $itemID (keys %{$hsh_ref}) {
			my $strand = $hsh_ref->{$itemID}{'bedLine'}[5];
			if (not exists $hsh_ref->{$itemID}{'rgbItem'}) {
				$hsh_ref->{$itemID}{'bedLine'}[8] = $strand_color_hsh_ref->{$strand};
			} else {
				$hsh_ref->{$itemID}{'bedLine'}[8] = $hsh_ref->{$itemID}{'rgbItem'};
			}
			print OUTBED join "", (join "\t", (@{$hsh_ref->{$itemID}{'bedLine'}})), "\n";
		}
		close OUTBED;
	};

	{
		my $filePath = "$result_bed_dir/$outputPrefix.cluster.annot.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all cluster, with cluster name (i.e. gene annotation) at 4th column";
		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			my $strand = $clusterInfoHsh_ref->{$clusterID}{'bedLine'}[5];
			my @bedAry = @{$clusterInfoHsh_ref->{$clusterID}{'bedLine'}};
			$bedAry[8] = $strand_color_hsh_ref->{$strand};
			$bedAry[3] = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
			print OUTBED join "", (join "\t", (@bedAry)), "\n";
		}
		close OUTBED;
	}

	{
		my $filePath = "$result_bed_dir/$outputPrefix.CRE.annot.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all CRE, with CRE name (i.e. gene annotation) at 4th column";
		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $CREID (keys %{$CREInfoHsh_ref}) {
			my @bedAry = @{$CREInfoHsh_ref->{$CREID}{'bedLine'}};
			$bedAry[8] = $CREInfoHsh_ref->{$CREID}{'rgbItem'};;
			$bedAry[3] = $CREInfoHsh_ref->{$CREID}{'CREName'};
			print OUTBED join "", (join "\t", (@bedAry)), "\n";
		}
		close OUTBED;
	}

}
sub printEnd5Bed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $dn_end5Rng, $tmp_bed_dir, $trnscptInfoHsh_ref, $up_end5Rng
#	output: $end5_point_bed_path, $end5_rng_bed_path
#	toCall: my ($end5_rng_bed_path, $end5_point_bed_path) = &printEnd5Bed($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir);
#	calledInLine: 192
#....................................................................................................................................................#

	my ($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir) = @_;

	&reportAndLogStatus("Printing transcript end5 bed", 10, "\n");#->2455

	my $end5_rng_bed_path = "$tmp_bed_dir/end5_rng.bed";
	my $end5_point_bed_path = "$tmp_bed_dir/end5_point.bed";
	open (END5RNGBED, "| sort -k1,1 -k2,2n >$end5_rng_bed_path");
	open (END5POINTBED, "| sort -k1,1 -k2,2n >$end5_point_bed_path");
	
	foreach my $trnscptID (sort keys %{$trnscptInfoHsh_ref}) {
		my $chrom = $trnscptInfoHsh_ref->{$trnscptID}{'chrom'};
		my $strand = $trnscptInfoHsh_ref->{$trnscptID}{'strand'};
		my @exonRngAry = sort {$a <=> $b} @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}};

		my ($end5Start, $end5End, $exon1stLength, $exon1stStart, $exon1stEnd);
		my $tssPoint;
		
		if ($strand eq '+') {
			($exon1stStart, $exon1stEnd) = ($exonRngAry[0], $exonRngAry[1]);
			$exon1stLength = $exon1stEnd - $exon1stStart + 1;
			$end5Start = $exon1stStart - $up_end5Rng;
			
			$tssPoint = $exon1stStart;
			
			if ($exon1stLength < $dn_end5Rng) {
				$end5End = $exon1stEnd;
			} else {
				$end5End = $exon1stStart + $dn_end5Rng;
			}
			
		} elsif ($strand eq '-') {

			($exon1stStart, $exon1stEnd) = ($exonRngAry[-2], $exonRngAry[-1]);
			$exon1stLength = $exon1stEnd - $exon1stStart + 1;
			$end5End = $exon1stEnd + $up_end5Rng;

			$tssPoint = $exon1stEnd+1;

			if ($exon1stLength < $dn_end5Rng) {
				$end5Start = $exon1stStart;
			} else {
				$end5Start = $exon1stEnd - $dn_end5Rng;
			}
			
		} else {
			die "strand $strand is invalid\n";
		}
		
		$end5Start = 2 if $end5Start <= 1;
		$exon1stEnd = 2 if $exon1stEnd <= 1;
		$end5End = 2 if $end5End <= 1;
		
		@{$trnscptInfoHsh_ref->{$trnscptID}{'exon1stRng'}} = ($exon1stStart, $exon1stEnd);
		@{$trnscptInfoHsh_ref->{$trnscptID}{'end5Rng'}} = ($end5Start, $end5End);
		my $end5RegionLength = $end5End - $end5Start + 1;
		$trnscptInfoHsh_ref->{$trnscptID}{'exon1stLength'} = $exon1stLength;
		$trnscptInfoHsh_ref->{$trnscptID}{'end5RegionLength'} = $end5RegionLength;
		
		my $tssEnd = $tssPoint;
		my $tssStart = $tssEnd-1;
		print END5POINTBED join "", (join "\t", ($chrom, $tssStart, $tssEnd, $trnscptID, '1', $strand)), "\n";
		print END5RNGBED join "", (join "\t", ($chrom, $end5Start, $end5End, $trnscptID, '1', $strand)), "\n";
	}
	close END5POINTBED;
	close END5RNGBED;

	return ($end5_rng_bed_path, $end5_point_bed_path);
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|220
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 223
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			@colLenCountHsh = sort {$b <=> $a} @colLenCountHsh;
			my $headerColLen = $colLenCountHsh[0]+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}
	
	@{$filelistLenCountHsh{'dir'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'dir'}};
	@{$filelistLenCountHsh{'name'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'name'}};
	@{$filelistLenCountHsh{'description'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'description'}};

	my $fileDir_colLen = $filelistLenCountHsh{'dir'}[0]+2;
	my $fileName_colLen = $filelistLenCountHsh{'name'}[0]+2;
	my $fileDescription_colLen = $filelistLenCountHsh{'description'}[0]+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|573
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|162, 4_finishingTasks|220
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 177, 224
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->573
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->573
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->573
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->573
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub printTableCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableCREInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 213
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.CRE.info.tsv.gz";
	open CRELOG, "| gzip -c >$filePath";
	my @headerAry = ('CREID', 'CREName', 'typeStr', 'mask', 'score', 'geneNum', 'clusterIDStr', 'trnscptIDStr', 'geneIDStr', 'geneNameStr', 'geneClassStr', 'codingClassStr', 'proximity', 'regionType', 'regionOritentation', 'regionGeneID', 'class', 'best_prob', 'best_clusterID', 'sumClusterRead');
	print CRELOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing CRE info", 0, "\n");#->2455

	$globalReadmeHsh_ref->{$filePath}{'description'} = "cis-regulatory element CRE annotation, one-row-per CRE, with infomation of its associated genes and clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] Identifier of the CAGE CRE.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREName'} = '[string] Name of the CRE, in format of [r][rank]@[geneNameX],[r][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] its cluster is masked, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'typeStr'} = '[string] the type of its cluster, annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNum'} = '[string] number of gene associated with the CRE';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneIDStr'} = '[string] Identifier of gene associated with its cluster, ";" delimited. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNameStr'} = '[string] Name of gene associated with its cluster, ";" delimited. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClassStr'} = '[string] Class of gene associated with its cluster, ";" delimited. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with its cluster, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'score'} = '[integer] score in the input bed';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClassStr'} = '[string] Assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionType'} = '[end5 exon intron or intergenic] within or in the proximity of the end5, exon or intron, or else intergenic';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionOritentation'} = '[ns ss or as] oritentation relative to the region in regionType, sense strand, antisense strand, or non-stranded';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionGeneID'} = '[unique ID] ID of the gene which contributes to the annotation of the regionType';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'proximity'} = '[proxmial or distal] proximity or distal to genes tss';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'class'} = '[coding, noncoding, distal and other] CRE of coding gene tss, CRE of noncoding genes tss or CRE that is distant from gene tss, or others (including CRE that is close to gene tss but not on the same strand as the gene of mixed of multiple genetypes)';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'best_clusterID'} = '[unique ID] ClusterID with best prob';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'best_prob'} = '[float] lowest prob among all ClusterID';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'sumClusterRead'} = '[integer] sum of read within its member cluster';

	my $count_hsh_ref = {};
	foreach my $CREID (sort keys %{$CREInfoHsh_ref}) {
		my $CREName = $CREInfoHsh_ref->{$CREID}{'CREName'};
		my $score = $CREInfoHsh_ref->{$CREID}{'score'};
		my $mask = $CREInfoHsh_ref->{$CREID}{'mask'};

		my %IDHsh = ();
		my $best_clusterID;
		my $best_prob = 0;
		
		foreach my $clusterID (sort keys %{$CREInfoHsh_ref->{$CREID}{'clusterID'}}) {
			my $prob = $clusterInfoHsh_ref->{$clusterID}{'prob'};
			if ($prob > $best_prob) {
				$best_clusterID = $clusterID;
				$best_prob = $prob;
			}
			
			my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
			foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
				my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
				my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
				my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				my $codingClass = 'unknown';
				$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});

				$IDHsh{'type'}{$type}++;
				$IDHsh{'clusterID'}{$clusterID}++;
				$IDHsh{'geneID'}{$geneID}++;
				$IDHsh{'trnscptID'}{$trnscptID}++;
				$IDHsh{'geneName'}{$geneName}++;
				$IDHsh{'geneClass'}{$geneClass}++;
				$IDHsh{'codingClass'}{$codingClass}++;
			}
		}

		my $typeStr = join ";", (sort keys %{$IDHsh{'type'}});
		my $clusterIDStr = join ";", (sort keys %{$IDHsh{'clusterID'}});
		my $trnscptIDStr = join ";", (sort keys %{$IDHsh{'trnscptID'}});
		my $geneIDStr = join ";", (sort keys %{$IDHsh{'geneID'}});
		my $geneNameStr = join ";", (sort keys %{$IDHsh{'geneName'}});
		my $geneClassStr = join ";", (sort keys %{$IDHsh{'geneClass'}});
		my $codingClassStr = join ";", (sort keys %{$IDHsh{'codingClass'}});
		my $geneNum = keys %{$IDHsh{'geneID'}};

		my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
		my $regionGeneID = $CREInfoHsh_ref->{$CREID}{'regionGeneID'};
		my $regionType = $CREInfoHsh_ref->{$CREID}{'regionType'};
		my $regionOritentation = $CREInfoHsh_ref->{$CREID}{'regionOritentation'};
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};

		my $class = 'other';
		
		if ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'coding'}) {
			$class = 'coding';
			
		} elsif ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'noncoding'}) {
			$class = 'noncoding';
			
		} elsif ($proximity eq 'distal') {
			$class = 'distal';
		}
		
		$count_hsh_ref->{'class'}{'count'}{$class}++;
		$count_hsh_ref->{'proximity'}{'count'}{$proximity}++;
		$count_hsh_ref->{'codingClassStr'}{'count'}{$codingClassStr}++;
		$count_hsh_ref->{'regionType'}{'count'}{$regionType}++;
		$count_hsh_ref->{'class'}{'total'}++;
		$count_hsh_ref->{'proximity'}{'total'}++;
		$count_hsh_ref->{'codingClassStr'}{'total'}++;
		$count_hsh_ref->{'regionType'}{'total'}++;
		
		print CRELOG join "", (join "\t", ($CREID, $CREName, $typeStr, $mask, $score, $geneNum, $clusterIDStr, $trnscptIDStr, $geneIDStr, $geneNameStr, $geneClassStr, $codingClassStr, $proximity, $regionType, $regionOritentation, $regionGeneID, $class, $best_prob, $best_clusterID, $sumClusterRead)), "\n";

	}
	close CRELOG;
	
	foreach my $anno_type (sort keys %{$count_hsh_ref}) {
		&reportAndLogStatus("--- CRE $anno_type count statistics ---", 10, "\n");#->2455
		my $total = $count_hsh_ref->{$anno_type}{'total'};
		foreach my $anno_ID (sort {$count_hsh_ref->{$anno_type}{'count'}{$b} <=> $count_hsh_ref->{$anno_type}{'count'}{$a}} keys %{$count_hsh_ref->{$anno_type}{'count'}}) {
			my $count = $count_hsh_ref->{$anno_type}{'count'}{$anno_ID};
			my $pct = sprintf "%.3f", 100*$count/$total;
			&reportAndLogStatus("CRE $anno_type: $anno_ID = $count [$pct%]", 10, "\n");#->2455

		}
	}
}
sub printTableClusterInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableClusterInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 209
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.cluster.info.tsv.gz";
	open CAGELOG, "| gzip -c >$filePath";
	my @headerAry = ('clusterID', 'clusterName', 'type', 'mask', 'score', 'geneNum', 'trnscptIDStr', 'geneIDStr', 'geneNameStr', 'geneClassStr', 'codingClassStr', 'proximity', 'regionType', 'regionOritentation', 'regionGeneID', 'class', 'CREID', 'prob');
	print CAGELOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing gene info", 0, "\n");#->2455

	$globalReadmeHsh_ref->{$filePath}{'description'} = "CAGE cluster centric annotation, one-row-per CAGE cluster, with infomation of its associated genes";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterID'} = '[unique ID] Identifier of the CAGE cluster.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterName'} = '[string] Name of the cluster, in format of [p|e][rank]@[geneNameX],[p|e][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] the CAGE cluster is masked, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'type'} = '[gene_tss or unanno_tss] the CAGE cluster is annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNum'} = '[string] number of gene associated with the CAGE cluster';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneIDStr'} = '[string] Identifier of gene associated with the CAGE cluster, ";" delimited. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNameStr'} = '[string] Name of gene associated with the CAGE cluster, ";" delimited. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClassStr'} = '[string] Class of gene associated with the CAGE cluster, ";" delimited. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with the CAGE cluster, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'score'} = '[integer] score in the input bed';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClassStr'} = '[string] Assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionType'} = '[end5 exon intron or intergenic] within or in the proximity of the end5, exon or intron, or else intergenic';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionOritentation'} = '[ns ss or as] oritentation relative to the region in regionType, sense strand, antisense strand, or non-stranded';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionGeneID'} = '[unique ID] ID of the gene which contributes to the annotation of the regionType';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'proximity'} = '[proxmial or distal] proximity or distal to genes tss';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'class'} = '[coding, noncoding, distal and other] cluster of coding gene tss, cluster of noncoding genes tss or cluster that is distant from gene tss, or others (including cluster that is close to gene tss but not on the same strand as the gene of mixed of multiple genetypes)';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] ID of the CRE the cluster belongs to';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'prob'} = '[float] False discovery rate of cluster on background filtering';

	my $count_hsh_ref = {};
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $clusterName = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
		my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
		my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
		my $mask = $clusterInfoHsh_ref->{$clusterID}{'mask'};
		my $CREID = $clusterInfoHsh_ref->{$clusterID}{'CREID'};
		my $prob = $clusterInfoHsh_ref->{$clusterID}{'prob'};
		my %IDHsh = ();
		foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
			my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
			my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
			my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
			my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
			my $codingClass = 'unknown';
			$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});

			$IDHsh{'geneID'}{$geneID}++;
			$IDHsh{'trnscptID'}{$trnscptID}++;
			$IDHsh{'geneName'}{$geneName}++;
			$IDHsh{'geneClass'}{$geneClass}++;
			$IDHsh{'codingClass'}{$codingClass}++;
		}
		my $trnscptIDStr = join ";", (sort keys %{$IDHsh{'trnscptID'}});
		my $geneIDStr = join ";", (sort keys %{$IDHsh{'geneID'}});
		my $geneNameStr = join ";", (sort keys %{$IDHsh{'geneName'}});
		my $geneClassStr = join ";", (sort keys %{$IDHsh{'geneClass'}});
		my $codingClassStr = join ";", (sort keys %{$IDHsh{'codingClass'}});
		my $geneNum = keys %{$IDHsh{'geneID'}};

		my $regionGeneID = $clusterInfoHsh_ref->{$clusterID}{'regionGeneID'};
		my $regionType = $clusterInfoHsh_ref->{$clusterID}{'regionType'};
		my $regionOritentation = $clusterInfoHsh_ref->{$clusterID}{'regionOritentation'};
		my $proximity = $clusterInfoHsh_ref->{$clusterID}{'proximity'};

		my $class = 'other';
		
		if ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'coding'}) {
			$class = 'coding';
			
		} elsif ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'noncoding'}) {
			$class = 'noncoding';
			
		} elsif ($proximity eq 'distal') {
			$class = 'distal';
		}
		
		$count_hsh_ref->{'class'}{'count'}{$class}++;
		$count_hsh_ref->{'proximity'}{'count'}{$proximity}++;
		$count_hsh_ref->{'codingClassStr'}{'count'}{$codingClassStr}++;
		$count_hsh_ref->{'regionType'}{'count'}{$regionType}++;
		$count_hsh_ref->{'class'}{'total'}++;
		$count_hsh_ref->{'proximity'}{'total'}++;
		$count_hsh_ref->{'codingClassStr'}{'total'}++;
		$count_hsh_ref->{'regionType'}{'total'}++;
		
		print CAGELOG join "", (join "\t", ($clusterID, $clusterName, $type, $mask, $score, $geneNum, $trnscptIDStr, $geneIDStr, $geneNameStr, $geneClassStr, $codingClassStr, $proximity, $regionType, $regionOritentation, $regionGeneID, $class, $CREID, $prob)), "\n";

	}
	close CAGELOG;
	
	foreach my $anno_type (sort keys %{$count_hsh_ref}) {
		&reportAndLogStatus("--- cluster $anno_type count statistics ---", 10, "\n");#->2455
		my $total = $count_hsh_ref->{$anno_type}{'total'};
		foreach my $anno_ID (sort {$count_hsh_ref->{$anno_type}{'count'}{$b} <=> $count_hsh_ref->{$anno_type}{'count'}{$a}} keys %{$count_hsh_ref->{$anno_type}{'count'}}) {
			my $count = $count_hsh_ref->{$anno_type}{'count'}{$anno_ID};
			my $pct = sprintf "%.3f", 100*$count/$total;
			&reportAndLogStatus("cluster  $anno_type: $anno_ID = $count [$pct%]", 10, "\n");#->2455

		}
	}
}
sub printTableGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir
#	output: none
#	toCall: &printTableGeneInfo($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 210
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	&reportAndLogStatus("Printing gene info", 0, "\n");#->2455

	my $filePath = "$result_log_dir/$outputPrefix.gene.info.tsv.gz";
	open GENELOG, "| gzip -c >$filePath";
	my @headerAry = ('geneID', 'geneClass', 'geneName', 'mask', 'trnscpt_num', 'cluster_num', 'end5_hit_num', 'exon_hit_num', 'addon_hit_num', 'trnscptIDStr', 'clusterIDStr', 'codingClass');
	print GENELOG join "", (join "\t", @headerAry), "\n";

	$globalReadmeHsh_ref->{$filePath}{'description'} = "Gene centric annotation, one-row-per gene, with its annotation and its associated CAGE clusters and transcripts";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscpt_num'} = '[non-zero positive integer] Num of transcripts associated with the gene.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'cluster_num'} = '[non-zero positive integer] Num of CAGE clusters associated with the gene.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'end5_hit_num'} = '[integer] num of CAGE cluster hit on 5\'end of its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'exon_hit_num'} = '[integer] num of CAGE cluster hit on exon of its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'addon_hit_num'} = '[integer] num of CAGE cluster addon for its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with the gene, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterIDStr'} = '[string] ID of cluster associated with the gene, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClass'} = '[coding, noncoding, pseudogene, others or unknown] assigned based on predefined coding status of geneClass';

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $trnscptIDStr = join ";", (sort keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}});
		my $clusterIDStr = join ";", (sort keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}});
		my $cluster_num = keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}};
		my $trnscpt_num = keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $mask = $geneInfoHsh_ref->{$geneID}{'mask'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $codingClass = 'unknown';
		$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
		my $end5_hit_num = 0;
		my $exon_hit_num = 0;
		my $addon_hit_num = 0;
		foreach my $clusterID (keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}}) {
			$end5_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'end5';
			$exon_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'exon';
			$addon_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'addon';
		}
	
		print GENELOG join "", (join "\t", ($geneID, $geneClass, $geneName, $mask, $trnscpt_num, $cluster_num, $end5_hit_num, $exon_hit_num, $addon_hit_num, $trnscptIDStr, $clusterIDStr, $codingClass)), "\n";
	}
	close GENELOG;

}
sub printTableIDMappingInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableIDMappingInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 211
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	&reportAndLogStatus("Printing ID mapping table log files", 10, "\n");#->2455

	my $filePath = "$result_log_dir/$outputPrefix.ID_mapping.info.tsv.gz";
	open IDLOG, "| gzip -c >$filePath";
	my @headerAry = ('clusterID', 'clusterName', 'type', 'trnscptID', 'geneID', 'geneName', 'geneClass', 'mask', 'rank', 'tag_count', 'hit', 'codingClass', 'CREID');
	print IDLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing ID mapping info", 0, "\n");#->2455

	$globalReadmeHsh_ref->{$filePath}{'description'} = "1-to-1 mapping between IDs of genes, transcripts and CAGE clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterID'} = '[unique ID] Identifier of the CAGE cluster.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterName'} = '[string] Name of the cluster, in format of [p|e][rank]@[geneNameX],[p|e][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'type'} = '[gene_tss or unanno_tss] the CAGE cluster is annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptID'} = '[unique ID] Identifier of the transcripts. Mainly inherited from the "transcript ID" field in GENCODE or FANTOM CAT, plus "addon" transcripts from unannotated CAGE clusters [ADDT#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'rank'} = '[integer] rank of the cluster within the gene';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'tag_count'} = '[integer] number of ctss tag count';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'hit'} = '[end5, exon or addon] location of clusterID "hit" on the transcript, can at 5\'end, on exon, or addon. exon hit will be turned of if exon_slop_rng==-1. addon refers to dummy transcripts added to unannotated CAGE clusters';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClass'} = '[coding, noncoding, pseudogene, others or unknown] assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] ID of the CRE the clusterID belongs to';
	
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
		my $clusterName = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
		my $CREID = $clusterInfoHsh_ref->{$clusterID}{'CREID'};
		foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
			my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
			my $mask = $trnscptInfoHsh_ref->{$trnscptID}{'mask'};
			my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
			my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
			my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
			my $rank = $clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID};
			my $tag_count = $clusterInfoHsh_ref->{$clusterID}{'score'};
			my $codingClass = 'unknown';
			$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
			print IDLOG join "", (join "\t", ($clusterID, $clusterName, $type, $trnscptID, $geneID, $geneName, $geneClass, $mask, $rank, $tag_count, $hit, $codingClass, $CREID)), "\n";
		}
	}
	close IDLOG;

}
sub printTableTranscriptInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableTranscriptInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 212
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.transcript.info.tsv.gz";
	open TRANSCRIPTLOG, "| gzip -c >$filePath";
	my @headerAry = ('trnscptID', 'geneID', 'geneClass', 'geneName', 'mask', 'cluster_num', 'end5_hit_num', 'exon_hit_num', 'addon_hit_num', 'clusterIDStr', 'codingClass');
	print TRANSCRIPTLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing transcript info", 0, "\n");#->2455

	$globalReadmeHsh_ref->{$filePath}{'description'} = "transcript centric annotation, one-row-per gene, with its gene annotation and its associated CAGE clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptID'} = '[unique ID] Identifier of the transcript. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated CAGE clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'cluster_num'} = '[non-zero positive integer] Num of CAGE clusters associated with the transcript.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'end5_hit_num'} = '[integer] num of CAGE cluster hit on 5\'end of it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'exon_hit_num'} = '[integer] num of CAGE cluster hit on exon of it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'addon_hit_num'} = '[integer] num of CAGE cluster addon for it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterIDStr'} = '[string] ID of cluster associated with the transcript, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	
	foreach my $trnscptID (sort keys %{$trnscptInfoHsh_ref}) {
		my $mask = $trnscptInfoHsh_ref->{$trnscptID}{'mask'};
		my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $codingClass = 'unknown';
		$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $clusterIDStr = join ";", (sort keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}});
		my $cluster_num = keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}};
		my $end5_hit_num = 0;
		my $exon_hit_num = 0;
		my $addon_hit_num = 0;
		foreach my $clusterID (keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}}) {
			$end5_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'end5';
			$exon_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'exon';
			$addon_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'addon';
		}

		print TRANSCRIPTLOG join "", (join "\t", ($trnscptID, $geneID, $geneClass, $geneName, $mask, $cluster_num, $end5_hit_num, $exon_hit_num, $addon_hit_num, $clusterIDStr, $codingClass)), "\n";
	}
	close TRANSCRIPTLOG;
}
sub printTrnscptGtf {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: exonRngToGtf|739
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $outputPrefix, $result_gtf_dir, $trnscptInfoHsh_ref
#	output: 
#	toCall: &printTrnscptGtf($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix);
#	calledInLine: 214
#....................................................................................................................................................#
	my ($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix) = @_;
	
	my $all_trnscpt_gtf_path = "$result_gtf_dir/$outputPrefix.gtf.gz";
	$globalReadmeHsh_ref->{$all_trnscpt_gtf_path}{'description'} = "It contains all transcripts, including the addon transcripts, without masking on structural RNA and small RNAs";

	my $mask_trnscpt_gtf_path = "$result_gtf_dir/$outputPrefix.masked.gtf.gz";
	$globalReadmeHsh_ref->{$mask_trnscpt_gtf_path}{'description'} = "It contains transcripts, including the addon transcripts, with structural RNA and small RNA masked, suitable for running cufflinks or stringtie";
	
	open (ALL, "| sort -k1,1 -k4,4n | gzip -c >$all_trnscpt_gtf_path");
	open (MASK, "| sort -k1,1 -k4,4n | gzip -c >$mask_trnscpt_gtf_path");

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $sourceTag = 'DGT';
		my $mask = $geneInfoHsh_ref->{$geneID}{'mask'};
		my $g_chrom = $geneInfoHsh_ref->{$geneID}{'chrom'};
		my $g_strand = $geneInfoHsh_ref->{$geneID}{'strand'};
		my ($geneStart, $geneEnd) = @{$geneInfoHsh_ref->{$geneID}{'geneRng'}};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $gtfStart = $geneStart;
		my $gtfEnd = $geneEnd;
		
		#chr1	FANTOM	gene	47082703	47083645	.	+	.	gene_id "CATG00000000004.1"; geneSuperClass "all_lncRNA";  geneClass "CATG00000000004.1";  geneSubClass "divergent_promoters"; gene_type "__na"; gene_name "CATG00000000004.1"; coding_status "nonCoding"; cumulative_support "ENCODE"; geneCategory "p_lncRNA_divergent"; DHS_type "DHS_promoter";	
		my @gene_line_ary = ($g_chrom, $sourceTag, 'gene', $gtfStart, $gtfEnd, '.', $g_strand, '.', "gene_id \"$geneID\"; geneClass \"$geneClass\"; gene_type \"$geneClass\"; gene_name \"$geneName\"; geneAnnoPlus \"$geneClass\";");
		print ALL join "", (join "\t", (@gene_line_ary)), "\n";
		if ($mask eq 'no') {
			print MASK join "", (join "\t", (@gene_line_ary)), "\n";
		}
		
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			my $chrom = $trnscptInfoHsh_ref->{$trnscptID}{'chrom'};
			my $strand = $trnscptInfoHsh_ref->{$trnscptID}{'strand'};

			my $exonRngAry_ref = $trnscptInfoHsh_ref->{$trnscptID}{'exonRng'};
			my ($gtf_ary_ref) = &exonRngToGtf($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag);#->739
		
			print ALL join "", (join "\t", (@{$_})), "\n" foreach @{$gtf_ary_ref};
			if ($mask eq 'no') {
				print MASK join "", (join "\t", (@{$_})), "\n" foreach @{$gtf_ary_ref};
			}
		}
	}
	
	close ALL;
	close MASK;

	return ();
}
sub rankCAGEClusterWithinGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &rankCAGEClusterWithinGene($clusterInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 203
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $geneInfoHsh_ref) = @_;

	my $proximity_tag_hsh_ref = {
		'proximal' => "P",
		'distal' => "D",
	};

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $clusterID (keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}}) {
			my $count = $clusterInfoHsh_ref->{$clusterID}{'count'};
			push @{$rank_hsh_ref->{$count}}, $clusterID;
		}

		my $rank = 1;
		foreach my $count (sort {$b <=> $a} keys %{$rank_hsh_ref}) {
			foreach my $clusterID (sort {$a cmp $b} @{$rank_hsh_ref->{$count}}) {
				$clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID} = $rank;
				$rank++;
			}
		}
	}	
	
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'rank'}}) {
			my $rank = $clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID};
			push @{$rank_hsh_ref->{$rank}}, $geneID;
		}

		my @clusterNameAry = ();
		foreach my $rank (sort {$a <=> $b} keys %{$rank_hsh_ref}) {
			foreach my $geneID (sort {$a cmp $b} @{$rank_hsh_ref->{$rank}}) {
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				push @clusterNameAry, "c$rank\@$geneName";
			}
		}

		my $proximity = $clusterInfoHsh_ref->{$clusterID}{'proximity'};
		my $proximity_tag = $proximity_tag_hsh_ref->{$proximity};
		my $clusterName = join ":", ($proximity_tag, (join ",", @clusterNameAry));
		$clusterInfoHsh_ref->{$clusterID}{'clusterName'} = $clusterName;
	}

	return ();
}
sub rankCREWithinGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &rankCREWithinGene($CREInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 206
#....................................................................................................................................................#
	my ($CREInfoHsh_ref, $geneInfoHsh_ref) = @_;

	my $proximity_tag_hsh_ref = {
		'proximal' => "P",
		'distal' => "D",
	};
	
	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $CREID (keys %{$geneInfoHsh_ref->{$geneID}{'CREID'}}) {
			my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
			push @{$rank_hsh_ref->{$sumClusterRead}}, $CREID;
		}

		my $rank = 1;
		foreach my $sumClusterRead (sort {$b <=> $a} keys %{$rank_hsh_ref}) {
			foreach my $CREID (sort {$a cmp $b} @{$rank_hsh_ref->{$sumClusterRead}}) {
				$CREInfoHsh_ref->{$CREID}{'rank'}{$geneID} = $rank;
				$rank++;
			}
		}
	}	
	
	foreach my $CREID (sort keys %{$CREInfoHsh_ref}) {

		my $rank_hsh_ref = {};
		foreach my $geneID (keys %{$CREInfoHsh_ref->{$CREID}{'rank'}}) {
			my $rank = $CREInfoHsh_ref->{$CREID}{'rank'}{$geneID};
			push @{$rank_hsh_ref->{$rank}}, $geneID;
		}

		my @CRENameAry = ();
		foreach my $rank (sort {$a <=> $b} keys %{$rank_hsh_ref}) {
			foreach my $geneID (sort {$a cmp $b} @{$rank_hsh_ref->{$rank}}) {
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				push @CRENameAry, "r$rank\@$geneName";
			}
		}
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};
		my $proximity_tag = $proximity_tag_hsh_ref->{$proximity};
		my $CREName = join ":", ($proximity_tag, (join ",", @CRENameAry));
		$CREInfoHsh_ref->{$CREID}{'CREName'} = $CREName;
	}

	return ();
}
sub readChromSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $chrom_size_path
#	output: $chrom_size_hsh_ref
#	toCall: my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);
#	calledInLine: 187
#....................................................................................................................................................#
	my ($chrom_size_path) = @_;
	
	my $chrom_size_hsh_ref = {};
	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($chrom, $size) = split /\s+/;
		$chrom_size_hsh_ref->{$chrom} = $size;
	}
	close CHROMSIZE;

	return ($chrom_size_hsh_ref);
}
sub readClusterBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $tssCluster_bed_path
#	output: $clusterInfoHsh_ref
#	toCall: my ($clusterInfoHsh_ref) = &readClusterBed($tssCluster_bed_path);
#	calledInLine: 193
#....................................................................................................................................................#

	my ($tssCluster_bed_path) = @_;

	my $clusterInfoHsh_ref = {};
	
	if ($tssCluster_bed_path =~ m/\.gz$/) {
		open (PROMOTERBED, " gzip -dc $tssCluster_bed_path|");
	} else {
		open (PROMOTERBED, "<", $tssCluster_bed_path);
	}
	
	while (<PROMOTERBED>) {
		chomp;

		my ($chrom, $start, $end, $clusterID, $score, $strand, $thickStart, $thickEnd) = split /\t/;
		
		#if ($strand ne '+' and $strand ne '-') {
		#	die "skip $clusterID: ambigous strand\n";
		#}
		
		if (not defined $thickStart or not defined $thickEnd) {
			my $mid_pt = int($start+($end-$start)/2);
			$thickEnd = $mid_pt;
			$thickStart = $mid_pt-1;
		}

		$clusterInfoHsh_ref->{$clusterID}{'strand'} = $strand;
		$clusterInfoHsh_ref->{$clusterID}{'chrom'} = $chrom;
		$clusterInfoHsh_ref->{$clusterID}{'start'} = $start;
		$clusterInfoHsh_ref->{$clusterID}{'end'} = $end;
		$clusterInfoHsh_ref->{$clusterID}{'type'} = 'unanno_tss';
		$clusterInfoHsh_ref->{$clusterID}{'peakPos'} = $thickEnd;
		$clusterInfoHsh_ref->{$clusterID}{'score'} = $score;
		$clusterInfoHsh_ref->{$clusterID}{'filter'} = 'no';

		my $chromStart = $start;
		my $chromEnd = $end;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
		
		$clusterInfoHsh_ref->{$clusterID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $clusterID, $score, $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];

	}
	close TRANSCRIPTBED;
	
	my $num_clusters = keys %{$clusterInfoHsh_ref};
	&reportAndLogStatus("$num_clusters clusters read", 10, "\n");#->2455

	return ($clusterInfoHsh_ref);

}
sub readClusterInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $tssCluster_info_path
#	output: 
#	toCall: &readClusterInfo($tssCluster_info_path, $clusterInfoHsh_ref);
#	calledInLine: 194
#....................................................................................................................................................#

	my ($tssCluster_info_path, $clusterInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading tssCluster info", 10, "\n");#->2455

	if ($tssCluster_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $tssCluster_info_path|");
	} else {
		open (FILEIN, "<", $tssCluster_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();

	foreach my $headerItem (qw/prob summit max count/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $clusterID = $splt[0];
		my $prob = $splt[$colIndexHsh{'prob'}];
		my $summit = $splt[$colIndexHsh{'summit'}];
		my $max = $splt[$colIndexHsh{'max'}];
		my $count = $splt[$colIndexHsh{'count'}];
		if (exists $clusterInfoHsh_ref->{$clusterID}) {
			$clusterInfoHsh_ref->{$clusterID}{'prob'} = $prob;
			$clusterInfoHsh_ref->{$clusterID}{'max'} = $max;
			$clusterInfoHsh_ref->{$clusterID}{'summit'} = $summit;
			$clusterInfoHsh_ref->{$clusterID}{'count'} = $count;
		}
	}
	close FILEIN;

	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'prob'}) {
			$clusterInfoHsh_ref->{$clusterID}{'prob'} = 1;
		}
	}
	
	return ();
}
sub readGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: getTextInfo
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $gene_info_path
#	output: 
#	toCall: &readGeneInfo($gene_info_path, $geneInfoHsh_ref);
#	calledInLine: 190
#....................................................................................................................................................#

	my ($gene_info_path, $geneInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading gene info", 10, "\n");#->2455

	if ($gene_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $gene_info_path|");
	} else {
		open (FILEIN, "<", $gene_info_path);
	}

	chomp(my $header = <FILEIN>);

	my %geneNameHsh = ();
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();
	
	foreach my $headerItem (qw/geneID geneName geneClass/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		
		if (not defined $colIndexHsh{$headerItem} and $headerItem eq 'geneClass') {
			foreach my $i (0..$#headerSplt) {
				$colIndexHsh{$headerItem} = $i if $headerSplt[$i] eq 'geneType';
			}
		}
		
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $geneID = $splt[$colIndexHsh{'geneID'}];
		my $geneName = $splt[$colIndexHsh{'geneName'}];
		my $geneClass = $splt[$colIndexHsh{'geneClass'}];
		
		if (exists $geneInfoHsh_ref->{$geneID}) {

			#---[2020/05/14 23:41] to make sure the genes are unique
			if (exists $geneNameHsh{$geneName}) {
				$geneNameHsh{$geneName}++;
				$geneName = $geneName.".".$geneNameHsh{$geneName};
			}
		
			$geneInfoHsh_ref->{$geneID}{'geneName'} = $geneName;
			$geneInfoHsh_ref->{$geneID}{'geneClass'} = $geneClass;
			$geneNameHsh{$geneName}++;
		}
	}
	close FILEIN;
	
	my $num_gene = keys %{$geneInfoHsh_ref};
	&reportAndLogStatus("$num_gene genes reads", 10, "\n");#->2455
	
	return ();
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|135
#	secondaryAppearInSection: >none
#	input: none
#	output: $CRE_extend_size, $CRE_extend_upstrm_ratio, $addon_length, $dn_end5Rng, $exon_slop_rng, $genome, $merge_dist, $merge_strandness, $outDir, $outputPrefix, $overwrite, $proximal_strandness, $proximity_slop_rng, $tssCluster_bed_path, $tssCluster_info_path, $up_end5Rng
#	toCall: my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 138
#....................................................................................................................................................#
	
	my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $outputPrefix, $outDir, $overwrite);
	
	$up_end5Rng = 500;
	$dn_end5Rng = 500;
	$merge_dist = 500;
	$addon_length = 500;
	$proximity_slop_rng = 500;
	$CRE_extend_size = 500;
	$exon_slop_rng = -1;
	$CRE_extend_upstrm_ratio = 4;
	$merge_strandness = 'strandless';
	$proximal_strandness = 'stranded';
	$overwrite = 'no';

	GetOptions 	(
		"tssCluster_bed_path=s"			=>	\$tssCluster_bed_path,
		"tssCluster_info_path=s"		=>	\$tssCluster_info_path,
		"genome=s"							=>	\$genome,
		"up_end5Rng:i"						=>	\$up_end5Rng,
		"dn_end5Rng:i"						=>	\$dn_end5Rng,
		"merge_dist:i"						=>	\$merge_dist,
		"addon_length:i"					=>	\$addon_length,
		"exon_slop_rng:i"					=>	\$exon_slop_rng,
		"proximity_slop_rng:i"			=>	\$proximity_slop_rng,
		"merge_strandness:s"				=>	\$merge_strandness,
		"proximal_strandness:s"			=>	\$proximal_strandness,
		"CRE_extend_size:i"				=>	\$CRE_extend_size,
		"CRE_extend_upstrm_ratio:f"	=>	\$CRE_extend_upstrm_ratio,
		"outputPrefix=s"					=>	\$outputPrefix,
		"outDir=s"							=>	\$outDir,
		"overwrite:s"						=>	\$overwrite,
		'help'								=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $tssCluster_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'tssCluster_bed_path' => $tssCluster_bed_path,
		'tssCluster_info_path' => $tssCluster_info_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $outputPrefix, $outDir, $overwrite);
}
sub readTranscriptBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $chrom_size_hsh_ref, $outDir, $tmp_bed_dir, $transcript_bed_path
#	output: $transcript_in_scope_bed_path, $trnscptInfoHsh_ref
#	toCall: my ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path) = &readTranscriptBed($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir);
#	calledInLine: 188
#....................................................................................................................................................#

	my ($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir) = @_;

	my $trnscptInfoHsh_ref = {};
	my $transcript_in_scope_bed_path = "$tmp_bed_dir/transcript_in_scope.bed";
	open TRNSCPTSCOPE, ">", $transcript_in_scope_bed_path;

	&reportAndLogStatus("Reading transcript bed", 10, "\n");#->2455
	
	open (TRANSCRIPTBED, "gzip -dc $transcript_bed_path |");
	while (<TRANSCRIPTBED>) {
		chomp;

		my ($chrom, $start, $end, $trnscptIDStr, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blkCount, $blkSizes, $blkStarts) = split /\t/;
		
		if (not exists $chrom_size_hsh_ref->{$chrom}) {
			#&reportAndLogStatus("trnscpt $trnscptIDStr will be skipped as it is on chrom $chrom that is outside the defined chromSize file", 10, "\n");#->2455
			next;
		}
		print TRNSCPTSCOPE $_."\n";
		
		if ($strand ne '+' and $strand ne '-') {
			die "skip $trnscptIDStr: ambigous strand\n";
		}

		my $trnscptStart = $start+1;
		my $trnscptEnd = $end;
		my @trnscptIDStrAry = split /\|/, $trnscptIDStr;
		my $trnscptID = $trnscptIDStrAry[-1];
		
		$trnscptInfoHsh_ref->{$trnscptID}{'strand'} = $strand;
		$trnscptInfoHsh_ref->{$trnscptID}{'chrom'} = $chrom;
		
		if ($trnscptInfoHsh_ref->{$trnscptID}{'strand'} eq '+') {
			$trnscptInfoHsh_ref->{$trnscptID}{'end5Pos'} = $trnscptStart;
		} elsif ($trnscptInfoHsh_ref->{$trnscptID}{'strand'} eq '-') {
			$trnscptInfoHsh_ref->{$trnscptID}{'end5Pos'} = $trnscptEnd;
		} else {
			die "trnscptID $trnscptID has amibigous strand\n";
		}

		$trnscptInfoHsh_ref->{$trnscptID}{'exonNum'} = $blkCount;
		$trnscptInfoHsh_ref->{$trnscptID}{'exonLen'} = sum(split /,/, $blkSizes);
		@{$trnscptInfoHsh_ref->{$trnscptID}{'trnscptRng'}} = ($trnscptStart, $trnscptEnd);
		$trnscptInfoHsh_ref->{$trnscptID}{'bedLine'} = [$chrom, $start, $end, $trnscptID, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blkCount, $blkSizes, $blkStarts];

		#---[5/26/14 18:26] get the exon ranges
		if ($blkCount > 1) {
			my @blkStartsSplt = split /,/, $blkStarts;
			my @blkSizesSplt = split /,/, $blkSizes;

			for my $i (0..$blkCount-1) {
				my $exonStart = $trnscptStart + $blkStartsSplt[$i];
				my $exonEnd = $exonStart + $blkSizesSplt[$i] - 1;
				push @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}}, ($exonStart, $exonEnd);
			}

		} else {
			@{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}} = ($trnscptStart, $trnscptEnd);
		}
	}
	close TRANSCRIPTBED;
	close TRNSCPTSCOPE;
	
	return ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path);

}
sub readTranscriptInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $transcript_info_path, $trnscptInfoHsh_ref
#	output: $geneInfoHsh_ref
#	toCall: my ($geneInfoHsh_ref) = &readTranscriptInfo($transcript_info_path, $trnscptInfoHsh_ref);
#	calledInLine: 189
#....................................................................................................................................................#

	my ($transcript_info_path, $trnscptInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading transcript info", 10, "\n");#->2455
	my $geneInfoHsh_ref = {};

	if ($transcript_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $transcript_info_path|");
	} else {
		open (FILEIN, "<", $transcript_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();
	
	foreach my $headerItem (qw/geneID trnscptID/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}

		if (not defined $colIndexHsh{$headerItem} and $headerItem eq 'trnscptID') {
			foreach my $i (0..$#headerSplt) {
				$colIndexHsh{$headerItem} = $i if $headerSplt[$i] eq 'transcriptID';
			}
		}
		
		
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $geneID = $splt[$colIndexHsh{'geneID'}];
		my $trnscptID = $splt[$colIndexHsh{'trnscptID'}];
		if (exists $trnscptInfoHsh_ref->{$trnscptID}) {
			$trnscptInfoHsh_ref->{$trnscptID}{'geneID'} = $geneID;
			$geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID}++;
		}
	}
	close FILEIN;

	my $num_transcript = keys %{$trnscptInfoHsh_ref};
	&reportAndLogStatus("$num_transcript transcripts reads", 10, "\n");#->2455
	
	return ($geneInfoHsh_ref);
}
sub removeTmpBedDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $tmp_bed_dir
#	output: none
#	toCall: &removeTmpBedDir($tmp_bed_dir);
#	calledInLine: 215
#....................................................................................................................................................#
	
	my ($tmp_bed_dir) = @_;
	
	&reportAndLogStatus("removing tmp_bed_dir", 10, "\n");#->2455
	system ("rm -rf $tmp_bed_dir");

}
sub removeUnsupportedGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &removeUnsupportedGene($geneInfoHsh_ref, $trnscptInfoHsh_ref);
#	calledInLine: 207
#....................................................................................................................................................#
	
	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref) = @_;
	
	my %itemHsh = (
		'gene' => $geneInfoHsh_ref,
		'transcript' => $trnscptInfoHsh_ref,
	);
	
	foreach my $item_type (keys %itemHsh) {
		&reportAndLogStatus("removing $item_type with no CAGE support", 10, "\n");#->2455
		my $hsh_ref = $itemHsh{$item_type};
		my $remove_num = 0;
		foreach my $itemID (keys %{$hsh_ref}) {
			if (not exists $hsh_ref->{$itemID}{'clusterID'}) {
				delete $hsh_ref->{$itemID};
				$remove_num++;
			};
		}
		
		&reportAndLogStatus("$remove_num $item_type removed", 10, "\n");#->2455
		
	};

	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			delete $geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID} if not exists $trnscptInfoHsh_ref->{$trnscptID};
		}
	}
	
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|573
#	appearInSub: addonTranscript|308, assignClusterProximity|405, checkBedtoolsVersion|513, defineCRE|591, filterUnannotatedCluster|763, generateExtendedCluster|842, getSuperCluster|908, intersectCluster|963, printAllBed|1049, printEnd5Bed|1129, printTableCREInfo|1364, printTableClusterInfo|1496, printTableGeneInfo|1611, printTableIDMappingInfo|1673, printTableTranscriptInfo|1733, readClusterBed|1991, readClusterInfo|2055, readGeneInfo|2116, readTranscriptBed|2253, readTranscriptInfo|2332, removeTmpBedDir|2394, removeUnsupportedGene|2413, summerizeGeneInfo|2597
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|162, 3_readInfo|184
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 324, 419, 439, 489, 498, 531, 535, 607, 637, 776, 789, 856, 925, 956, 979, 987, 1077, 1143, 1382, 1485, 1490, 1514, 1600, 1605, 1625, 1687, 1693, 1751, 2049, 2069, 2130, 2183, 2271, 2280, 2346, 2389, 2408, 2433, 2443, 2611
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->573
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->573
	
	return ();
}
sub storeCREInfoFromBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: defineCRE|591
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|184
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $proximity, $tmp_merged_CRE_bed
#	output: 
#	toCall: &storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);
#	calledInLine: 633, 659
#....................................................................................................................................................#
	my ($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref) = @_;

	open MERGECREBED, "<", "$tmp_merged_CRE_bed";
	while (<MERGECREBED>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $clusterIDStr, $score, $strandStr) = split /\t/;
		my $strand = $strandStr;
		$strand = '.' if $strandStr =~ m/\;/;
		my $CREID = "$chrom\_$chromStart\_$chromEnd\_$strand";
		my $max_clusterID = undef;
		my $max_count = 0;
		
		foreach my $clusterID (split /;/, $clusterIDStr) {
			my $max = $clusterInfoHsh_ref->{$clusterID}{'max'};
			if ($max > $max_count) {
				$max_clusterID = $clusterID; 
				$max_count = $max;
			}

			$CREInfoHsh_ref->{$CREID}{'clusterID'}{$clusterID}++;
			$clusterInfoHsh_ref->{$clusterID}{'CREID'} = $CREID;
		}
		$CREInfoHsh_ref->{$CREID}{'strand'} = $strand;
		$CREInfoHsh_ref->{$CREID}{'chrom'} = $chrom;
		$CREInfoHsh_ref->{$CREID}{'start'} = $chromStart;
		$CREInfoHsh_ref->{$CREID}{'end'} = $chromEnd;
		$CREInfoHsh_ref->{$CREID}{'score'} = $score;
		$CREInfoHsh_ref->{$CREID}{'proximity'} = $proximity;

		$CREInfoHsh_ref->{$CREID}{'regionType'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionType'};
		$CREInfoHsh_ref->{$CREID}{'regionGeneID'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionGeneID'};
		$CREInfoHsh_ref->{$CREID}{'regionOritentation'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionOritentation'};

	}
	close MERGECREBED;

	return ();
}
sub summerizeCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &summerizeCREInfo($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 205
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref) = @_;
	
	foreach my $CREID (keys %{$CREInfoHsh_ref}) {
		my @CRENameAry = ();
		my $mask = 'no';
		my $max = 0;
		my $peakPos;
		my $sumClusterRead = 0;

		foreach my $clusterID (keys %{$CREInfoHsh_ref->{$CREID}{'clusterID'}}) {
			foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'geneID'}}) {
				$CREInfoHsh_ref->{$CREID}{'geneID'}{$geneID}++;
				$geneInfoHsh_ref->{$geneID}{'CREID'}{$CREID}++;
			}

			my $count = $clusterInfoHsh_ref->{$clusterID}{'count'};
			$sumClusterRead+=$count;
			foreach my $promoter_name (split /\,/, $clusterInfoHsh_ref->{$clusterID}{'clusterName'}) {
				push @CRENameAry, $promoter_name;
			}
			if ($clusterInfoHsh_ref->{$clusterID}{'max'} > $max) {
				$max = $clusterInfoHsh_ref->{$clusterID}{'max'};
				$peakPos = $clusterInfoHsh_ref->{$clusterID}{'peakPos'};
			}
			$mask = 'yes' if $clusterInfoHsh_ref->{$clusterID}{'mask'} eq 'yes';
		}
		my $chrom = $CREInfoHsh_ref->{$CREID}{'chrom'};
		my $start = $CREInfoHsh_ref->{$CREID}{'start'};
		my $end = $CREInfoHsh_ref->{$CREID}{'end'};
		my $score = $CREInfoHsh_ref->{$CREID}{'score'};
		my $strand = $CREInfoHsh_ref->{$CREID}{'strand'};

		my $chromStart = $start;
		my $chromEnd = $end;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
		my $thickEnd = $peakPos;
		my $thickStart = $thickEnd - 1;

		$CREInfoHsh_ref->{$CREID}{'sumClusterRead'} = $sumClusterRead;
		$CREInfoHsh_ref->{$CREID}{'mask'} = $mask;
		$CREInfoHsh_ref->{$CREID}{'peakPos'} = $peakPos;
		if ($CREInfoHsh_ref->{$CREID}{'proximity'} eq 'proximal') {
			$CREInfoHsh_ref->{$CREID}{'rgbItem'} = '106,61,154';

		} elsif ($CREInfoHsh_ref->{$CREID}{'proximity'} eq 'distal') {
			$CREInfoHsh_ref->{$CREID}{'rgbItem'} = '255,127,0';
		
		} else {
			die;
		}

		$CREInfoHsh_ref->{$CREID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $CREID, $sumClusterRead, $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];
	}

	return ();
}
sub summerizeGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2455
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|184
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &summerizeGeneInfo($geneInfoHsh_ref, $trnscptInfoHsh_ref);
#	calledInLine: 200
#....................................................................................................................................................#

	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref) = @_;
	
	&reportAndLogStatus("summerizing gene information", 10, "\n");#->2455
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my @tmpRngAry = ();
		my %strandHsh = ();
		my %chromHsh = ();
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			$strandHsh{$trnscptInfoHsh_ref->{$trnscptID}{'strand'}}++;
			$chromHsh{$trnscptInfoHsh_ref->{$trnscptID}{'chrom'}}++;
			push @tmpRngAry, @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}};
		}
		
		my @chromAry = keys %chromHsh;
		die "chrom error\n" if @chromAry != 1;
		my $chrom = shift(@chromAry);
		
		@tmpRngAry = sort {$a <=> $b} @tmpRngAry;
		my $geneStart = $tmpRngAry[0];
		my $geneEnd = $tmpRngAry[-1];
		my $strand = '.';
		
		if (exists $strandHsh{'+'} and not exists $strandHsh{'-'}) {
			$strand = '+';
		} elsif (not exists $strandHsh{'+'} and exists $strandHsh{'-'}) {
			$strand = '-';
		}
		
		$geneInfoHsh_ref->{$geneID}{'chrom'} = $chrom;
		$geneInfoHsh_ref->{$geneID}{'strand'} = $strand;
		$geneInfoHsh_ref->{$geneID}{'geneRng'} = [$geneStart, $geneEnd];

		my $chromStart = $geneStart;
		my $chromEnd = $geneEnd;
		my $thickStart = $chromStart;
		my $thickEnd = $chromEnd;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
	
		$geneInfoHsh_ref->{$geneID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $geneID, '0', $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];
		
	}
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 123
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































