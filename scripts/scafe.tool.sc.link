#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use threads ('stack_size' => 64*4096);
use threads::shared;
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                  ---> scafe.tool.sc.link <---
                   <--- tool, single-cell mode, linking tCRE by coactivity --->

 Description:
   This tool links tCREs by their coactivity among single cells using cicero

 Usage:
   scafe.tool.sc.link [options] --count --run_chr --genome --CRE_bed_path --CRE_info_path --outputPrefix --outDir
   
   --CRE_bed_path     <required> [string]  bed file contains the regions of CRE,
                                      *.CRE.coord.bed.gz from scafe.tool.cm.annotate.pl
   --CRE_info_path    <required> [string]  tsv file contains the annoations of CREs, 
                                      *..CRE.info.tsv.gz from scafe.tool.cm.annotate.pl
   --count_dir        <required> [string]  a dir contains the UMI count of the CRE
   --genome           <required> [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix     <required> [string]  prefix for the output files
   --outDir           <required> [string]  directory for the output files
   --network_cutoff   (optional) [0-1]     minimum coactivity to define cis-coactivity network (default = 0.05)
   --link_cutoff   (optional) [integer] minimum coactivity to output as link(default = 0.2)
   --binarize_CRE_exp (optional) [yes/no]  binarize_CRE_exp CRE expression signal or not (default = no)
   --min_cell         (optional) [integer] minimum number of cells the CRE to be expressed (default = 5)
   --Rscript_bin      (optional) [string]  path to the Rscript bin, aim to allow users to supply an R version other the 
                                           system wide R version. Package Caret must be installed. (default = Rscript)
   --max_thread       (optional) [integer] maximum number of parallel threads, capped at 10 to 
                                           avoid memory overflow (default=5)
   --run_chr          (optional) [string]  comma delimited list of chromosome name to run,
                                           use 'all' to run all chromosome (default=all)
   --overwrite        (optional) [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   R packages: 'docopt','monocle3', 'cicero', 'Matrix', 'data.table', 'scales'

 For demo, cd to SCAFE dir and run,
   scafe.tool.sc.link \
   --overwrite=yes \
   --max_thread=10 \
   --CRE_bed_path=./demo/input/sc.link/demo.CRE.coord.bed.gz \
   --CRE_info_path=./demo/input/sc.link/demo.CRE.info.tsv.gz \
   --count_dir=./demo/input/sc.link/matrix/ \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.link/

=head1 VERSION

1.0

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->949
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->267
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($CRE_bed_path, $CRE_info_path, $count_dir, $genome, $max_thread, $min_cell, $run_chr, $binarize_CRE_exp, $Rscript_bin, $network_cutoff, $link_cutoff, $outputPrefix, $outDir, $overwrite) = &readParameters();#->863
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
$max_thread = 10 if $max_thread > 10;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_cicero_dir = "$result_dir/cicero/"; push @mkDirAry, $result_cicero_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->475
&printStartOrFinishMessage("startMessage");#->718
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_output
#
#<section ID="output" num="3">
my ($get_cicero_cds_R, $run_cicero_link_R) = &checkRScriptVersion($Rscript_bin);#->226
my ($chrom_size_path) = &checkChromSizePath($genome);#->206
my ($chrom_size_hsh_ref) = &generateChromSizeHsh($chrom_size_path, $run_chr);#->285
my ($CRE_info_hsh_ref, $gene_info_hsh_ref) = &readCREInfo($CRE_info_path);#->752
&readCREbed($CRE_info_hsh_ref, $CRE_bed_path);#->827
my ($thread_info_hsh_ref) = &generateThreadInfoHsh($max_thread, $chrom_size_hsh_ref, $result_cicero_dir);#->436
my ($cicero_cds_path) = &generateCiceroCDS($get_cicero_cds_R, $result_cicero_dir, $min_cell, $Rscript_bin, $CRE_bed_path, $count_dir, $binarize_CRE_exp);#->321
&generateCiceroLink($thread_info_hsh_ref, $run_cicero_link_R, $Rscript_bin, $cicero_cds_path, $chrom_size_path, $network_cutoff);#->363
&parseCiceroLink($CRE_info_hsh_ref, $gene_info_hsh_ref, $thread_info_hsh_ref, $link_cutoff, $result_log_dir);#->500
&parseCiceroNetwork($CRE_info_hsh_ref, $thread_info_hsh_ref, $result_log_dir);#->544
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->603
&printStartOrFinishMessage("finishMessage");#->718
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	checkTools [n=1]:
#		checkRScriptVersion
#
#	general [n=6]:
#		checkRScriptVersion, currentTime, logCalledCMDAndScript
#		printStartOrFinishMessage, readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=9]:
#		checkChromSizePath, generateChromSizeHsh, generateCiceroCDS
#		generateCiceroLink, generateThreadInfoHsh, parseCiceroLink
#		parseCiceroNetwork, readCREInfo, readCREbed
#
#====================================================================================================================================================#

sub checkChromSizePath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_size_path
#	toCall: my ($chrom_size_path) = &checkChromSizePath($genome);
#	calledInLine: 154
#....................................................................................................................................................#
	my ($genome) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	
	return ($chrom_size_path);
}
sub checkRScriptVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $Rscript_bin
#	output: $get_cicero_cds_R, $run_cicero_link_R
#	toCall: my ($get_cicero_cds_R, $run_cicero_link_R) = &checkRScriptVersion($Rscript_bin);
#	calledInLine: 153
#....................................................................................................................................................#
	
	my ($Rscript_bin) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $get_cicero_cds_R = "$dirPath/../resources/R/get_cicero_cds.R";
	my $run_cicero_link_R = "$dirPath/../resources/R/run_cicero_link.R";
	my $benchmark_roc_R = "$dirPath/../resources/R/benchmark_roc.R";

	my $stdOut = `$Rscript_bin --version 2>&1`;
	if ($stdOut =~ m/R scripting front-end version (\S+)/) {
		&reportAndLogStatus("Checking: Rscript version: $1", 0, "\n");#->927
	} else {
		die "Rscript is not installed properly at $Rscript_bin. Quitting.\n";
	}
	
	if (-s $get_cicero_cds_R) {
		&reportAndLogStatus("get_cicero_cds_R found.", 0, "\n");#->927
	} else {
		die "Rscript get_cicero_cds_R is not found. Quitting.\n";
	}

	if (-s $run_cicero_link_R) {
		&reportAndLogStatus("run_cicero_link_R found.", 0, "\n");#->927
	} else {
		die "Rscript run_cicero_link_R is not found. Quitting.\n";
	}

	return($get_cicero_cds_R, $run_cicero_link_R);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|718, reportAndLogStatus|927
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|133, 4_finishingTasks|167
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 105, 734, 738, 743, 747, 943, 944
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub generateChromSizeHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $chrom_size_path, $run_chr
#	output: $chrom_size_hsh_ref
#	toCall: my ($chrom_size_hsh_ref) = &generateChromSizeHsh($chrom_size_path, $run_chr);
#	calledInLine: 155
#....................................................................................................................................................#
	
	my ($chrom_size_path, $run_chr) = @_;
	
	my $run_chr_hsh_ref = {};
	if ($run_chr ne 'all') {
		foreach my $chrom (split /,/, $run_chr) {
			$run_chr_hsh_ref->{$chrom}++;
		}
	}
	
	my $chrom_size_hsh_ref = {};
	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($chrom, $size) = split /\s+/;
		if ($run_chr eq 'all' or exists $run_chr_hsh_ref->{$chrom}) {
			&reportAndLogStatus("$chrom of $size nt will be processed", 10, "\n");#->927
			$chrom_size_hsh_ref->{$chrom} = $size;
		}
	}
	close CHROMSIZE;

	return ($chrom_size_hsh_ref);
}
sub generateCiceroCDS {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $CRE_bed_path, $Rscript_bin, $binarize_CRE_exp, $count_dir, $get_cicero_cds_R, $min_cell, $result_cicero_dir
#	output: $cicero_cds_path
#	toCall: my ($cicero_cds_path) = &generateCiceroCDS($get_cicero_cds_R, $result_cicero_dir, $min_cell, $Rscript_bin, $CRE_bed_path, $count_dir, $binarize_CRE_exp);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($get_cicero_cds_R, $result_cicero_dir, $min_cell, $Rscript_bin, $CRE_bed_path, $count_dir, $binarize_CRE_exp) = @_;
	
	my $binarize = 'FALSE';
	$binarize = 'yes' if $binarize_CRE_exp eq 'yes';
	my $cicero_cds_path = "$result_cicero_dir/cicero_cds.RDS";
	my $R_stdout_path = "$result_cicero_dir/get_cicero_cds_R.stdout.txt";
	my $R_stderr_path = "$result_cicero_dir/get_cicero_cds_R.stderr.txt";
	
	if (not -s $cicero_cds_path) {
		my $cmd = join " ", (
			$Rscript_bin,
			$get_cicero_cds_R,
			"--count $count_dir",
			"--peaks $CRE_bed_path",
			"--min $min_cell",
			"--binarize $binarize",
			"--out $result_cicero_dir"
		);

		&reportAndLogStatus("Running get_cicero_cds. It'll take a while.", 10, "\n");#->927
		system ("$cmd 1>$R_stdout_path 2>$R_stderr_path");
		
	} else {
		&reportAndLogStatus("cicero_cds_path found.", 10, "\n");#->927
	}
	
	if (not -s $cicero_cds_path) {
		&reportAndLogStatus("cicero cds generation failed.", 10, "\n");
		&reportAndLogStatus("checking $R_stderr_path.", 10, "\n");
		&reportAndLogStatus("=================================", 10, "\n");
		system "less $R_stderr_path";
		die "check cicero installion. quitting\n";
	}

	return ($cicero_cds_path);
}
sub generateCiceroLink {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $Rscript_bin, $chrom_size_path, $cicero_cds_path, $network_cutoff, $run_cicero_link_R, $thread_info_hsh_ref
#	output: 
#	toCall: &generateCiceroLink($thread_info_hsh_ref, $run_cicero_link_R, $Rscript_bin, $cicero_cds_path, $chrom_size_path, $network_cutoff);
#	calledInLine: 160
#....................................................................................................................................................#
	my ($thread_info_hsh_ref, $run_cicero_link_R, $Rscript_bin, $cicero_cds_path, $chrom_size_path, $network_cutoff) = @_;
	
	my %threadHsh = ();
	foreach my $threadID (sort {$a <=> $b} keys %{$thread_info_hsh_ref}) {
		($threadHsh{$threadID}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
	
			sub {
				
				my $chr_list = $thread_info_hsh_ref->{$threadID}{'chr_list'};
				my $ciero_out_dir = $thread_info_hsh_ref->{$threadID}{'ciero_out_dir'};
				my $cicero_link_path = $thread_info_hsh_ref->{$threadID}{'cicero_link_path'};
				my $cicero_ccan_path = $thread_info_hsh_ref->{$threadID}{'cicero_ccan_path'};
				my $R_stdout_path = "$ciero_out_dir/run_cicero_link_R.stdout.txt";
				my $R_stderr_path = "$ciero_out_dir/run_cicero_link_R.stderr.txt";
				
				&reportAndLogStatus("$chr_list spawned to thread $threadID", 10, "\n");#->927
				if (not -s $cicero_link_path or not -s $cicero_ccan_path) {
					my $cmd = join " ", (
						$Rscript_bin,
						$run_cicero_link_R,
						"--chr_size_TSV $chrom_size_path",
						"--cicero_cds_RDS $cicero_cds_path",
						"--cutoff $network_cutoff",
						"--chr_list $chr_list",
						"--out $ciero_out_dir"
					);
					system ("$cmd 1>$R_stdout_path 2>$R_stderr_path");
				
				} else {
					&reportAndLogStatus("links of $chr_list found. skipping.", 10, "\n");#->927
				}
				
				if (not -s $cicero_link_path or not -s $cicero_ccan_path) {
					&reportAndLogStatus("failed to generate links for $chr_list. ", 10, "\n");
					&reportAndLogStatus("checking $R_stderr_path.", 10, "\n");
					&reportAndLogStatus("=================================", 10, "\n");
					system "less $R_stderr_path";
					die "check cicero installion. quitting\n";
				}

				return ();
			}
		);
	}
	
	while (keys %threadHsh) {

		my @threads = threads->list();
		my $thread_count = threads->list();
		my @running = threads->list(threads::running);
		my @joinable = threads->list(threads::joinable);
		my $running_count = @running;
		my $joinable_count = @joinable;

		&reportAndLogStatus("$thread_count threads exists. $running_count running and $joinable_count joinable", 10, "\n");#->927

		foreach my $threadID (keys %threadHsh) {
			if (not $threadHsh{$threadID}->is_running() or $threadHsh{$threadID}->is_joinable() or $threadHsh{$threadID}->is_detached()) {
				&reportAndLogStatus("thread $threadID is finishing.", 10, "\n");#->927
				$threadHsh{$threadID}->join();
				delete $threadHsh{$threadID};
			}
		}
		sleep 5;
	}	

	return ();
}
sub generateThreadInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $chrom_size_hsh_ref, $max_thread, $result_cicero_dir
#	output: $thread_info_hsh_ref
#	toCall: my ($thread_info_hsh_ref) = &generateThreadInfoHsh($max_thread, $chrom_size_hsh_ref, $result_cicero_dir);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($max_thread, $chrom_size_hsh_ref, $result_cicero_dir) = @_;
	
	my $thread_info_hsh_ref = {};

	my $threadID = 1;
	foreach my $chrom (sort {$chrom_size_hsh_ref->{$b} <=> $chrom_size_hsh_ref->{$a}} keys %{$chrom_size_hsh_ref}) {
		$threadID = 1 if $threadID > $max_thread;
		push @{$thread_info_hsh_ref->{$threadID}{'chrom'}}, $chrom;
		$threadID++;
	}
	
	foreach my $threadID (sort keys %{$thread_info_hsh_ref}) {
		my $chr_tag = join "_", @{$thread_info_hsh_ref->{$threadID}{'chrom'}};
		my $ciero_out_dir = "$result_cicero_dir/$chr_tag/";
		my $cicero_link_path = "$ciero_out_dir/cicero_link.tsv.gz";
		my $cicero_ccan_path = "$ciero_out_dir/cicero_cis_coactivity_network.tsv.gz";
		system "mkdir -pm 755 $ciero_out_dir";
		my $chr_list = join ",", @{$thread_info_hsh_ref->{$threadID}{'chrom'}};
		$thread_info_hsh_ref->{$threadID}{'cicero_link_path'} = $cicero_link_path;
		$thread_info_hsh_ref->{$threadID}{'cicero_ccan_path'} = $cicero_ccan_path;
		$thread_info_hsh_ref->{$threadID}{'ciero_out_dir'} = $ciero_out_dir;
		$thread_info_hsh_ref->{$threadID}{'chr_list'} = $chr_list;
		&reportAndLogStatus("thread $threadID will process $chr_list", 10, "\n");#->927
	}

	return ($thread_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|133
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 144
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub parseCiceroLink {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $gene_info_hsh_ref, $link_cutoff, $result_log_dir, $thread_info_hsh_ref
#	output: 
#	toCall: &parseCiceroLink($CRE_info_hsh_ref, $gene_info_hsh_ref, $thread_info_hsh_ref, $link_cutoff, $result_log_dir);
#	calledInLine: 161
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $gene_info_hsh_ref, $thread_info_hsh_ref, $link_cutoff, $result_log_dir) = @_;
	
	my $all_cicero_link_log_path = "$result_log_dir/cicero.coactivity.link.redundant.non_zero.tsv.gz";
	my $all_link_hsh_ref = {};
	foreach my $threadID (keys %{$thread_info_hsh_ref}) {
		my $cicero_link_path = $thread_info_hsh_ref->{$threadID}{'cicero_link_path'};
		my $chr_list = $thread_info_hsh_ref->{$threadID}{'chr_list'};
		&reportAndLogStatus("Parsing links on $chr_list", 10, "\n");#->927
		open (LINK, "gzip -dc $cicero_link_path|");
		<LINK>;
		while (<LINK>) {
			chomp;
			my ($CRE1, $CRE2, $coactivity) = split /\t/;
			next if length($coactivity) == 0;
			next if $coactivity == 0;
			$all_link_hsh_ref->{$CRE1}{$CRE2} = sprintf "%.5f", $coactivity;
		}
		close LINK;
	}

	open (ALLLINK, "| gzip -c >$all_cicero_link_log_path");
	print ALLLINK join "", (join "\t", ('CRE1', 'CRE2', 'coactivity')), "\n";
	foreach my $CRE1 (sort keys %{$all_link_hsh_ref}) {
		foreach my $CRE2 (sort keys %{$all_link_hsh_ref->{$CRE1}}) {
			my $coactivity = $all_link_hsh_ref->{$CRE1}{$CRE2};
			print ALLLINK join "", (join "\t", ($CRE1, $CRE2, $coactivity)), "\n";
		}
	}
	close ALLLINK;
	
	return ();
}
sub parseCiceroNetwork {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $result_log_dir, $thread_info_hsh_ref
#	output: 
#	toCall: &parseCiceroNetwork($CRE_info_hsh_ref, $thread_info_hsh_ref, $result_log_dir);
#	calledInLine: 162
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $thread_info_hsh_ref, $result_log_dir) = @_;
	
	my $cicero_network_log_path = "$result_log_dir/cicero.coactivity.network.tsv.gz";
	my $tmp_CCAN_info_hsh_ref = {};
	foreach my $threadID (keys %{$thread_info_hsh_ref}) {
		my $cicero_ccan_path = $thread_info_hsh_ref->{$threadID}{'cicero_ccan_path'};
		my $chr_list = $thread_info_hsh_ref->{$threadID}{'chr_list'};
		&reportAndLogStatus("Parsing ccan on $chr_list", 10, "\n");#->927
		open (CCAN, "gzip -dc $cicero_ccan_path|");
		<CCAN>;
		while (<CCAN>) {
			chomp;
			my ($CREID, $CCAN_num) = split /\t/;
			my $chrom = $CRE_info_hsh_ref->{$CREID}{'chrom'};
			my $summit = $CRE_info_hsh_ref->{$CREID}{'summit'};
			my $tmp_CCANID = $threadID.".".$CCAN_num;
			$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'CREID'}{$CREID}++;
			$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'chrom'} = $chrom;
			push @{$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'summit'}}, $summit;
		}
		close CCAN;
	}
	
	my $CCAN_info_hsh_ref = {};
	foreach my $tmp_CCANID (sort keys %{$tmp_CCAN_info_hsh_ref}) {
		my $chrom = $tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'chrom'};
		@{$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'summit'}} = sort {$a <=> $b} @{$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'summit'}};
		my $min = $tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'summit'}[0];
		my $max = $tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'summit'}[-1];
		my $CCANID = join "_", ("CCAN", $chrom, $min, $max);
		die "duplicated CCANID $CCANID\n" if exists $CCAN_info_hsh_ref->{$CCANID};
		foreach  my $CREID (keys %{$tmp_CCAN_info_hsh_ref->{$tmp_CCANID}{'CREID'}}) {
			$CCAN_info_hsh_ref->{$CCANID}{'CREID'}{$CREID}++;
		}
	}
	
	open (ALLCCAN, "| gzip -c >$cicero_network_log_path");
	print ALLCCAN join "", (join "\t", ('CCANID', 'CREID')), "\n";
	foreach my $CCANID (sort keys %{$CCAN_info_hsh_ref}) {
		foreach  my $CREID (keys %{$CCAN_info_hsh_ref->{$CCANID}{'CREID'}}) {
			print ALLCCAN join "", (join "\t", ($CCANID, $CREID)), "\n";
		}
	}
	close ALLLINK;
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|167
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 170
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|267
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|133, 4_finishingTasks|167
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 145, 171
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->267
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->267
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->267
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->267
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub readCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $CRE_info_path
#	output: $CRE_info_hsh_ref, $gene_info_hsh_ref
#	toCall: my ($CRE_info_hsh_ref, $gene_info_hsh_ref) = &readCREInfo($CRE_info_path);
#	calledInLine: 156
#....................................................................................................................................................#
	my ($CRE_info_path) = @_;
	
	my $CRE_info_hsh_ref = {};
	my $gene_info_hsh_ref = {};
	
	&reportAndLogStatus("Reading CRE info", 10, "\n");#->927
	
	if ($CRE_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $CRE_info_path|");
	} else {
		open (FILEIN, "<", $CRE_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();

	#CREID	CREName	typeStr	mask	score	geneNum	clusterIDStr	trnscptIDStr	geneIDStr	geneNameStr	geneClassStr	codingClassStr	proximity	regionType	regionOritentation	regionGeneID	class	best_prob	best_clusterID	sumClusterRead
	#chr10_102046327_102046828_-	P:r1@BLOC1S2	gene_tss	no	21	1	chr10_102046389_102046463_-	ENST00000361832.2_1;ENST00000370372.7_5;ENST00000441611.5_2;ENST00000579542.1_3;ENST00000614731.4_2	ENSG00000196072.12_5	BLOC1S2	protein_coding	coding	proximal	end5	ss	ENSG00000196072.12_5	coding	0.99997224	chr10_102046389_102046463_-	22
	#chr10_102106466_102106967_+	P:r1@SCD	gene_tss	no	50	1	chr10_102106834_102107002_+	ENST00000370355.3_2	ENSG00000099194.6_3	SCD	protein_coding	coding	proximal	end5	ss	ENSG00000099194.6_3	coding	0.999818308	chr10_102106834_102107002_+	51
	#chr10_102132986_102133700_+	P:r1@OLMALINC	gene_tss	no	22	1	chr10_102133383_102133389_+;chr10_102133598_102133617_+	ENST00000454935.1_2;ENST00000608396.2_2;ENST00000641087.1_1;ENST00000641571.1_1;ENST00000641708.1_2;ENST00000641799.1_1;ENST00000654233.1_1;ENST00000654288.1_1;ENST00000654563.1_1;ENST00000656449.1_1;ENST00000657262.1_1;ENST00000657502.1_1;ENST00000658059.1_1;ENST00000659075.1_1;ENST00000659159.1_1;ENST00000659770.1_1;ENST00000661096.1_1;ENST00000661158.1_1;ENST00000662018.1_1;ENST00000662712.1_1;ENST00000663103.1_1;ENST00000664100.1_1;ENST00000664224.1_1;ENST00000664225.1_1;ENST00000664516.1_1;ENST00000665022.1_1;ENST00000665755.1_1;ENST00000666045.1_1;ENST00000666154.1_1;ENST00000666713.1_1;ENST00000667278.1_1;ENST00000668101.1_1;ENST00000668316.1_1;ENST00000669693.1_1	ENSG00000235823.3_5	OLMALINC	lncRNA	noncoding	proximal	end5	ss	ENSG00000235823.3_5	noncoding	0.971380635	chr10_102133383_102133389_+	13

	foreach my $headerItem (qw/CREID CREName geneIDStr geneNameStr proximity regionType regionOritentation/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		die if not defined $colIndexHsh{$headerItem};
	}

	my $lineProc = 0;
	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		$lineProc++;
		chomp;
		&reportAndLogStatus("$lineProc lines processed", 10, "\r");	##->927
		my @splt = split /\t/;
		my $CREID = $splt[$colIndexHsh{'CREID'}];
		my $CREName = $splt[$colIndexHsh{'CREName'}];
		my $geneIDStr = $splt[$colIndexHsh{'geneIDStr'}];
		my $geneNameStr = $splt[$colIndexHsh{'geneNameStr'}];
		my $proximity = $splt[$colIndexHsh{'proximity'}];
		my $regionType = $splt[$colIndexHsh{'regionType'}];
		my $regionOritentation = $splt[$colIndexHsh{'regionOritentation'}];
		$CRE_info_hsh_ref->{$CREID}{'CREName'} = $CREName;
		$CRE_info_hsh_ref->{$CREID}{'proximity'} = $proximity;
		$CRE_info_hsh_ref->{$CREID}{'regionType'} = $regionType;
		$CRE_info_hsh_ref->{$CREID}{'regionOritentation'} = $regionOritentation;
		my @geneID_ary = split /;/, $geneIDStr;
		my @geneName_ary = split /;/, $geneNameStr;
		foreach my $i (0..$#geneID_ary) {
			my $geneID = $geneID_ary[$i];
			my $geneName = $geneName_ary[$i];
			
			$CRE_info_hsh_ref->{$CREID}{'geneID'}{$geneID} = 'proximal';
			$gene_info_hsh_ref->{$geneID}{'CREID'}{$CREID}  = 'proximal';
			$gene_info_hsh_ref->{$geneID}{'geneName'} = $geneName;
		}
	}
	close FILEIN;

	return ($CRE_info_hsh_ref, $gene_info_hsh_ref);
}
sub readCREbed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|927
#	appearInSub: >none
#	primaryAppearInSection: 3_output|150
#	secondaryAppearInSection: >none
#	input: $CRE_bed_path, $CRE_info_hsh_ref
#	output: 
#	toCall: &readCREbed($CRE_info_hsh_ref, $CRE_bed_path);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $CRE_bed_path) = @_;
	
	&reportAndLogStatus("Reading CRE summit", 10, "\n");#->927
	
	if ($CRE_bed_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $CRE_bed_path|");
	} else {
		open (FILEIN, "<", $CRE_bed_path);
	}
	while (<FILEIN>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $CREID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = split /\t/;
		die "$CREID exists in bed but absent in info\n" if not exists $CRE_info_hsh_ref->{$CREID};
		$CRE_info_hsh_ref->{$CREID}{'chrom'} = $chrom;
		$CRE_info_hsh_ref->{$CREID}{'summit'} = $thickEnd;
	}
	close FILEIN;

	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
		die "$CREID exists in info but absent in bed\n" if not exists $CRE_info_hsh_ref->{$CREID}{'summit'};
	}

	return ();
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|116
#	secondaryAppearInSection: >none
#	input: none
#	output: $CRE_bed_path, $CRE_info_path, $Rscript_bin, $binarize_CRE_exp, $count_dir, $genome, $link_cutoff, $max_thread, $min_cell, $network_cutoff, $outDir, $outputPrefix, $overwrite, $run_chr
#	toCall: my ($CRE_bed_path, $CRE_info_path, $count_dir, $genome, $max_thread, $min_cell, $run_chr, $binarize_CRE_exp, $Rscript_bin, $network_cutoff, $link_cutoff, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 119
#....................................................................................................................................................#
	
	my ($CRE_bed_path, $CRE_info_path, $count_dir, $genome, $max_thread, $min_cell, $run_chr, $binarize_CRE_exp, $Rscript_bin, $network_cutoff, $link_cutoff, $outputPrefix, $outDir, $overwrite);

	$overwrite = 'no';
	$max_thread = 5;
	$min_cell = 5;
	$link_cutoff = 0.2;
	$network_cutoff = 0.05;
	$run_chr = 'all';
	$Rscript_bin = 'Rscript';
	$binarize_CRE_exp = 'no';
	
	GetOptions 	(
		"CRE_bed_path=s"		=>	\$CRE_bed_path,
		"CRE_info_path=s"		=>	\$CRE_info_path,
		"count_dir=s"			=>	\$count_dir,
		"genome=s"				=>	\$genome,
		"min_cell=i"			=>	\$min_cell,
		"link_cutoff=s"		=>	\$link_cutoff,
		"network_cutoff=s"	=>	\$network_cutoff,
		"count_dir=s"			=>	\$count_dir,
		"binarize_CRE_exp=s"	=>	\$binarize_CRE_exp,
		"max_thread=s"			=>	\$max_thread,
		"Rscript_bin=s"		=>	\$Rscript_bin,
		"run_chr=s"				=>	\$run_chr,
		"outputPrefix=s"		=>	\$outputPrefix,
		"outDir:s"				=>	\$outDir,
		"overwrite:s"			=>	\$overwrite,
		'help'					=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $CRE_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'CRE_bed_path' => $CRE_bed_path,
		'CRE_info_path' => $CRE_info_path,
		'count_dir_matrix_mtx' => $count_dir."/matrix.mtx",
		'count_dir_genes_tsv' => $count_dir."/genes.tsv",
		'count_dir_barcodes_tsv' => $count_dir."/barcodes.tsv",
	};

	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($CRE_bed_path, $CRE_info_path, $count_dir, $genome, $max_thread, $min_cell, $run_chr, $binarize_CRE_exp, $Rscript_bin, $network_cutoff, $link_cutoff, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|267
#	appearInSub: checkRScriptVersion|226, generateChromSizeHsh|285, generateCiceroCDS|321, generateCiceroLink|363, generateThreadInfoHsh|436, parseCiceroLink|500, parseCiceroNetwork|544, readCREInfo|752, readCREbed|827
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_output|150
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 247, 253, 259, 312, 351, 355, 387, 403, 421, 425, 469, 518, 562, 768, 798, 840
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->267
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->267
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 104
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































